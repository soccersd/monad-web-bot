{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\cymst\\\\Documents\\\\monad bot\\\\frontend\\\\src\\\\context\\\\AppContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect } from 'react';\n\n// Define API base URL - same as in the original LogsPage.js\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';\n\n// Mock data for workflows (to be replaced by API data eventually)\nconst MOCK_WORKFLOWS = [{\n  id: 1,\n  name: 'Workflow Name is Test Ja',\n  type: 'stake',\n  contractType: 'kitsu'\n}, {\n  id: 2,\n  name: 'NFT Minter workflow',\n  type: 'deploy',\n  contractType: 'counter'\n}, {\n  id: 3,\n  name: 'Workflow#5',\n  type: 'swap',\n  fromToken: 'ETH',\n  toToken: 'USDC'\n}, {\n  id: 4,\n  name: 'Token Send Workflow',\n  type: 'send',\n  mode: 'random'\n}];\n\n// Create the context\nconst AppContext = /*#__PURE__*/createContext();\n\n// Provider component that wraps the app\nexport const AppProvider = ({\n  children\n}) => {\n  _s();\n  // Workflows state\n  const [workflows, setWorkflows] = useState(MOCK_WORKFLOWS);\n  const [selectedWorkflowId, setSelectedWorkflowId] = useState(2); // Default to NFT Minter\n\n  // Wallets state - fetched from separate API eventually\n  const [wallets, setWallets] = useState([{\n    id: 1,\n    address: '0x9996..9099',\n    privateKey: '0x1234...',\n    balance: 9.6399,\n    selected: true\n  }, {\n    id: 2,\n    address: '0x33b6..b433',\n    privateKey: '0x2345...',\n    balance: 0.0000,\n    selected: true\n  }, {\n    id: 3,\n    address: '0x696a..cc69',\n    privateKey: '0x3456...',\n    balance: 5.6284,\n    selected: true\n  }, {\n    id: 4,\n    address: '0x6664..3866',\n    privateKey: '0x4567...',\n    balance: 5.5618,\n    selected: false\n  }]);\n\n  // Tasks/runs state - will be fetched from API\n  const [tasks, setTasks] = useState([]);\n  const [isLoadingTasks, setIsLoadingTasks] = useState(false);\n  const [taskError, setTaskError] = useState(null);\n\n  // Get the selected workflow\n  const selectedWorkflow = workflows.find(w => w.id === selectedWorkflowId) || workflows[0];\n\n  // Get selected wallets (for running workflows)\n  const selectedWallets = wallets.filter(w => w.selected);\n\n  // Function to select a workflow\n  const selectWorkflow = id => {\n    setSelectedWorkflowId(id);\n  };\n\n  // Function to toggle wallet selection\n  const toggleWalletSelection = id => {\n    setWallets(wallets.map(wallet => wallet.id === id ? {\n      ...wallet,\n      selected: !wallet.selected\n    } : wallet));\n  };\n\n  // Function to fetch tasks from API\n  const fetchTasks = async () => {\n    setIsLoadingTasks(true);\n    setTaskError(null);\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/v1/tasks`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      // Process and format the tasks data\n      const tasksData = Object.entries(data.tasks || {}).map(([id, task]) => ({\n        id,\n        ...task,\n        startTime: new Date(task.start_time)\n      }));\n\n      // Sort by start time, newest first\n      tasksData.sort((a, b) => b.startTime - a.startTime);\n      setTasks(tasksData);\n    } catch (error) {\n      console.error(\"Failed to fetch tasks:\", error);\n      setTaskError(`Error fetching tasks: ${error.message}`);\n      setTasks([]);\n    } finally {\n      setIsLoadingTasks(false);\n    }\n  };\n\n  // Function to run a workflow via the API\n  const runWorkflow = async () => {\n    if (!selectedWorkflow || selectedWallets.length === 0) {\n      return {\n        success: false,\n        message: \"No workflow selected or no wallets selected\"\n      };\n    }\n    try {\n      // Depending on the workflow type, call different API endpoints\n      let endpoint = '';\n      let payloadData = {\n        private_keys: selectedWallets.map(w => w.privateKey),\n        delay_between_keys_seconds: 30,\n        delay_between_cycles_seconds: 60,\n        task_description: `${selectedWorkflow.name} (Manual run)`\n      };\n      switch (selectedWorkflow.type) {\n        case 'stake':\n          endpoint = '/api/v1/start-stake-cycle';\n          payloadData = {\n            ...payloadData,\n            contract_type: selectedWorkflow.contractType || 'kitsu',\n            amount_mon: 0.01,\n            // Default small amount\n            cycles: 1,\n            mode: 'random',\n            tx_count: 1\n          };\n          break;\n        case 'deploy':\n          endpoint = '/api/v1/start-deploy';\n          payloadData = {\n            ...payloadData,\n            contract_name: 'Counter',\n            contract_symbol: 'CNT',\n            cycles: 1\n          };\n          break;\n        case 'swap':\n          endpoint = '/api/v1/start-swap';\n          payloadData = {\n            ...payloadData,\n            token_from_symbol: selectedWorkflow.fromToken || 'ETH',\n            token_to_symbol: selectedWorkflow.toToken || 'USDC',\n            amount_str: '0.001',\n            cycles: 1,\n            mode: 'manual'\n          };\n          break;\n        case 'send':\n          endpoint = '/api/v1/start-send';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.001,\n            tx_count: 1,\n            mode: selectedWorkflow.mode || 'random'\n          };\n          break;\n        default:\n          return {\n            success: false,\n            message: `Unsupported workflow type: ${selectedWorkflow.type}`\n          };\n      }\n\n      // Make the API call to run the workflow\n      const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payloadData)\n      });\n      if (!response.ok) {\n        throw new Error(`API error: ${response.status}`);\n      }\n      const result = await response.json();\n\n      // Refresh the tasks list after starting a new one\n      await fetchTasks();\n      return {\n        success: true,\n        message: \"Workflow started successfully\",\n        data: result\n      };\n    } catch (error) {\n      console.error(\"Error running workflow:\", error);\n      return {\n        success: false,\n        message: `Failed to run workflow: ${error.message}`\n      };\n    }\n  };\n\n  // Fetch tasks when component mounts\n  useEffect(() => {\n    fetchTasks();\n    // Set up a polling interval to refresh tasks\n    const interval = setInterval(fetchTasks, 10000); // Refresh every 10 seconds\n\n    return () => clearInterval(interval); // Clean up on unmount\n  }, []);\n\n  // The context value that will be passed to consumers\n  const contextValue = {\n    workflows,\n    selectedWorkflow,\n    selectedWorkflowId,\n    selectWorkflow,\n    wallets,\n    toggleWalletSelection,\n    selectedWallets,\n    tasks,\n    isLoadingTasks,\n    taskError,\n    fetchTasks,\n    runWorkflow\n  };\n  return /*#__PURE__*/_jsxDEV(AppContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 199,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the app context\n_s(AppProvider, \"upbxb58Q6LdHHW7q43erV9yHxNo=\");\n_c = AppProvider;\nexport const useAppContext = () => {\n  _s2();\n  const context = useContext(AppContext);\n  if (context === undefined) {\n    throw new Error('useAppContext must be used within an AppProvider');\n  }\n  return context;\n};\n_s2(useAppContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default AppContext;\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","jsxDEV","_jsxDEV","API_BASE_URL","process","env","REACT_APP_API_BASE_URL","MOCK_WORKFLOWS","id","name","type","contractType","fromToken","toToken","mode","AppContext","AppProvider","children","_s","workflows","setWorkflows","selectedWorkflowId","setSelectedWorkflowId","wallets","setWallets","address","privateKey","balance","selected","tasks","setTasks","isLoadingTasks","setIsLoadingTasks","taskError","setTaskError","selectedWorkflow","find","w","selectedWallets","filter","selectWorkflow","toggleWalletSelection","map","wallet","fetchTasks","response","fetch","ok","Error","status","data","json","tasksData","Object","entries","task","startTime","Date","start_time","sort","a","b","error","console","message","runWorkflow","length","success","endpoint","payloadData","private_keys","delay_between_keys_seconds","delay_between_cycles_seconds","task_description","contract_type","amount_mon","cycles","tx_count","contract_name","contract_symbol","token_from_symbol","token_to_symbol","amount_str","method","headers","body","JSON","stringify","result","interval","setInterval","clearInterval","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAppContext","_s2","context","undefined","$RefreshReg$"],"sources":["C:/Users/cymst/Documents/monad bot/frontend/src/context/AppContext.js"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect } from 'react';\r\n\r\n// Define API base URL - same as in the original LogsPage.js\r\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';\r\n\r\n// Mock data for workflows (to be replaced by API data eventually)\r\nconst MOCK_WORKFLOWS = [\r\n  { id: 1, name: 'Workflow Name is Test Ja', type: 'stake', contractType: 'kitsu' },\r\n  { id: 2, name: 'NFT Minter workflow', type: 'deploy', contractType: 'counter' },\r\n  { id: 3, name: 'Workflow#5', type: 'swap', fromToken: 'ETH', toToken: 'USDC' },\r\n  { id: 4, name: 'Token Send Workflow', type: 'send', mode: 'random' },\r\n];\r\n\r\n// Create the context\r\nconst AppContext = createContext();\r\n\r\n// Provider component that wraps the app\r\nexport const AppProvider = ({ children }) => {\r\n  // Workflows state\r\n  const [workflows, setWorkflows] = useState(MOCK_WORKFLOWS);\r\n  const [selectedWorkflowId, setSelectedWorkflowId] = useState(2); // Default to NFT Minter\r\n  \r\n  // Wallets state - fetched from separate API eventually\r\n  const [wallets, setWallets] = useState([\r\n    { id: 1, address: '0x9996..9099', privateKey: '0x1234...', balance: 9.6399, selected: true },\r\n    { id: 2, address: '0x33b6..b433', privateKey: '0x2345...', balance: 0.0000, selected: true },\r\n    { id: 3, address: '0x696a..cc69', privateKey: '0x3456...', balance: 5.6284, selected: true },\r\n    { id: 4, address: '0x6664..3866', privateKey: '0x4567...', balance: 5.5618, selected: false },\r\n  ]);\r\n  \r\n  // Tasks/runs state - will be fetched from API\r\n  const [tasks, setTasks] = useState([]);\r\n  const [isLoadingTasks, setIsLoadingTasks] = useState(false);\r\n  const [taskError, setTaskError] = useState(null);\r\n  \r\n  // Get the selected workflow\r\n  const selectedWorkflow = workflows.find(w => w.id === selectedWorkflowId) || workflows[0];\r\n  \r\n  // Get selected wallets (for running workflows)\r\n  const selectedWallets = wallets.filter(w => w.selected);\r\n  \r\n  // Function to select a workflow\r\n  const selectWorkflow = (id) => {\r\n    setSelectedWorkflowId(id);\r\n  };\r\n  \r\n  // Function to toggle wallet selection\r\n  const toggleWalletSelection = (id) => {\r\n    setWallets(wallets.map(wallet => \r\n      wallet.id === id ? { ...wallet, selected: !wallet.selected } : wallet\r\n    ));\r\n  };\r\n  \r\n  // Function to fetch tasks from API\r\n  const fetchTasks = async () => {\r\n    setIsLoadingTasks(true);\r\n    setTaskError(null);\r\n    try {\r\n      const response = await fetch(`${API_BASE_URL}/api/v1/tasks`);\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      const data = await response.json();\r\n      // Process and format the tasks data\r\n      const tasksData = Object.entries(data.tasks || {}).map(([id, task]) => ({\r\n        id,\r\n        ...task,\r\n        startTime: new Date(task.start_time),\r\n      }));\r\n      \r\n      // Sort by start time, newest first\r\n      tasksData.sort((a, b) => b.startTime - a.startTime);\r\n      setTasks(tasksData);\r\n    } catch (error) {\r\n      console.error(\"Failed to fetch tasks:\", error);\r\n      setTaskError(`Error fetching tasks: ${error.message}`);\r\n      setTasks([]);\r\n    } finally {\r\n      setIsLoadingTasks(false);\r\n    }\r\n  };\r\n  \r\n  // Function to run a workflow via the API\r\n  const runWorkflow = async () => {\r\n    if (!selectedWorkflow || selectedWallets.length === 0) {\r\n      return { success: false, message: \"No workflow selected or no wallets selected\" };\r\n    }\r\n    \r\n    try {\r\n      // Depending on the workflow type, call different API endpoints\r\n      let endpoint = '';\r\n      let payloadData = {\r\n        private_keys: selectedWallets.map(w => w.privateKey),\r\n        delay_between_keys_seconds: 30,\r\n        delay_between_cycles_seconds: 60,\r\n        task_description: `${selectedWorkflow.name} (Manual run)`\r\n      };\r\n      \r\n      switch (selectedWorkflow.type) {\r\n        case 'stake':\r\n          endpoint = '/api/v1/start-stake-cycle';\r\n          payloadData = {\r\n            ...payloadData,\r\n            contract_type: selectedWorkflow.contractType || 'kitsu',\r\n            amount_mon: 0.01, // Default small amount\r\n            cycles: 1,\r\n            mode: 'random',\r\n            tx_count: 1,\r\n          };\r\n          break;\r\n        \r\n        case 'deploy':\r\n          endpoint = '/api/v1/start-deploy';\r\n          payloadData = {\r\n            ...payloadData,\r\n            contract_name: 'Counter',\r\n            contract_symbol: 'CNT',\r\n            cycles: 1,\r\n          };\r\n          break;\r\n          \r\n        case 'swap':\r\n          endpoint = '/api/v1/start-swap';\r\n          payloadData = {\r\n            ...payloadData,\r\n            token_from_symbol: selectedWorkflow.fromToken || 'ETH',\r\n            token_to_symbol: selectedWorkflow.toToken || 'USDC',\r\n            amount_str: '0.001',\r\n            cycles: 1,\r\n            mode: 'manual',\r\n          };\r\n          break;\r\n          \r\n        case 'send':\r\n          endpoint = '/api/v1/start-send';\r\n          payloadData = {\r\n            ...payloadData,\r\n            amount_mon: 0.001,\r\n            tx_count: 1,\r\n            mode: selectedWorkflow.mode || 'random',\r\n          };\r\n          break;\r\n          \r\n        default:\r\n          return { success: false, message: `Unsupported workflow type: ${selectedWorkflow.type}` };\r\n      }\r\n      \r\n      // Make the API call to run the workflow\r\n      const response = await fetch(`${API_BASE_URL}${endpoint}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(payloadData),\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`API error: ${response.status}`);\r\n      }\r\n      \r\n      const result = await response.json();\r\n      \r\n      // Refresh the tasks list after starting a new one\r\n      await fetchTasks();\r\n      \r\n      return { success: true, message: \"Workflow started successfully\", data: result };\r\n    } catch (error) {\r\n      console.error(\"Error running workflow:\", error);\r\n      return { success: false, message: `Failed to run workflow: ${error.message}` };\r\n    }\r\n  };\r\n  \r\n  // Fetch tasks when component mounts\r\n  useEffect(() => {\r\n    fetchTasks();\r\n    // Set up a polling interval to refresh tasks\r\n    const interval = setInterval(fetchTasks, 10000); // Refresh every 10 seconds\r\n    \r\n    return () => clearInterval(interval); // Clean up on unmount\r\n  }, []);\r\n  \r\n  // The context value that will be passed to consumers\r\n  const contextValue = {\r\n    workflows,\r\n    selectedWorkflow,\r\n    selectedWorkflowId,\r\n    selectWorkflow,\r\n    wallets,\r\n    toggleWalletSelection,\r\n    selectedWallets,\r\n    tasks,\r\n    isLoadingTasks,\r\n    taskError,\r\n    fetchTasks,\r\n    runWorkflow\r\n  };\r\n  \r\n  return (\r\n    <AppContext.Provider value={contextValue}>\r\n      {children}\r\n    </AppContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook to use the app context\r\nexport const useAppContext = () => {\r\n  const context = useContext(AppContext);\r\n  if (context === undefined) {\r\n    throw new Error('useAppContext must be used within an AppProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\nexport default AppContext; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}