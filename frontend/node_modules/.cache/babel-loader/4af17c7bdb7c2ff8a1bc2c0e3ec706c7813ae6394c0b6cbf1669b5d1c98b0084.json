{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\cymst\\\\Documents\\\\monad bot\\\\frontend\\\\src\\\\context\\\\AppContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect } from 'react';\nimport { v4 as uuidv4 } from 'uuid'; // Import UUID for step IDs\n\n// Define API base URL - same as in the original LogsPage.js\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';\n\n// Mock data for workflows (to be replaced by API data eventually)\nconst MOCK_WORKFLOWS = [{\n  id: 1,\n  name: 'Kitsu Stake',\n  type: 'stake',\n  contractType: 'kitsu',\n  steps: []\n}, {\n  id: 2,\n  name: 'NFT Minter (Counter)',\n  type: 'deploy',\n  contractType: 'counter',\n  steps: []\n}, {\n  id: 3,\n  name: 'Uniswap Swap',\n  type: 'swap',\n  fromToken: 'ETH',\n  toToken: 'USDC',\n  steps: []\n}, {\n  id: 4,\n  name: 'Send MON',\n  type: 'send',\n  mode: 'random',\n  steps: []\n}, {\n  id: 5,\n  name: 'Bebop Wrap/Unwrap',\n  type: 'bebop',\n  steps: []\n}, {\n  id: 6,\n  name: 'Izumi Wrap/Unwrap',\n  type: 'izumi',\n  steps: []\n}, {\n  id: 7,\n  name: 'Lilchogstars Mint',\n  type: 'lilchogstars',\n  steps: []\n}, {\n  id: 8,\n  name: 'Mono Transaction',\n  type: 'mono',\n  steps: []\n}, {\n  id: 9,\n  name: 'Rubic Swap MON->USDT',\n  type: 'rubic',\n  steps: []\n}, {\n  id: 10,\n  name: 'Ambient Swap (Random)',\n  type: 'ambient',\n  steps: []\n}, {\n  id: 11,\n  name: 'Apriori Full Cycle',\n  type: 'apriori',\n  steps: []\n}, {\n  id: 12,\n  name: 'Bean Swap (MON->USDC)',\n  type: 'bean',\n  steps: []\n}, {\n  id: 13,\n  name: 'Bima Lend',\n  type: 'bima',\n  steps: []\n}];\n\n// Create the context\nconst AppContext = /*#__PURE__*/createContext();\n\n// Provider component that wraps the app\nexport const AppProvider = ({\n  children\n}) => {\n  _s();\n  // Workflows state\n  const [workflows, setWorkflows] = useState(MOCK_WORKFLOWS);\n  const [selectedWorkflowId, setSelectedWorkflowId] = useState(2); // Default to NFT Minter\n\n  // Wallets state - starts empty now\n  const [wallets, setWallets] = useState([]);\n\n  // Wallet loading state\n  const [isLoadingWallets, setIsLoadingWallets] = useState(false);\n  const [walletError, setWalletError] = useState(null);\n  const [isImportingWallet, setIsImportingWallet] = useState(false);\n\n  // New wallet import form state\n  const [newWalletImport, setNewWalletImport] = useState({\n    privateKey: '',\n    nickname: ''\n  });\n\n  // Tasks/runs state - will be fetched from API\n  const [tasks, setTasks] = useState([]);\n  const [isLoadingTasks, setIsLoadingTasks] = useState(false);\n  const [taskError, setTaskError] = useState(null);\n\n  // Get the selected workflow\n  const selectedWorkflow = workflows.find(w => w.id === selectedWorkflowId) || workflows[0];\n\n  // Get selected wallets (for running workflows)\n  const selectedWallets = wallets.filter(w => w.selected);\n\n  // Function to select a workflow\n  const selectWorkflow = id => {\n    setSelectedWorkflowId(id);\n  };\n\n  // Function to toggle wallet selection\n  const toggleWalletSelection = id => {\n    setWallets(wallets.map(wallet => wallet.id === id ? {\n      ...wallet,\n      selected: !wallet.selected\n    } : wallet));\n  };\n\n  // Function to import a new wallet using backend API\n  const importWallet = async (privateKey, nickname = '') => {\n    setIsImportingWallet(true);\n    setWalletError(null);\n    try {\n      // Basic frontend validation (backend validates format too)\n      if (!privateKey.startsWith('0x') || privateKey.length !== 66) {\n        throw new Error('Invalid private key format (must be 0x followed by 64 hex chars)');\n      }\n\n      // Step 1: Call backend to get the real address from the private key\n      const addressResponse = await fetch(`${API_BASE_URL}/api/v1/get-address-from-key`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          private_key: privateKey\n        })\n      });\n      if (!addressResponse.ok) {\n        let errorMsg = 'Failed to derive address from key.';\n        try {\n          const errorData = await addressResponse.json();\n          errorMsg = errorData.detail || errorMsg;\n        } catch {/* Ignore if response body is not JSON */}\n        throw new Error(errorMsg);\n      }\n      const addressData = await addressResponse.json();\n      const realAddress = addressData.address;\n\n      // Check if wallet with this address already exists\n      if (wallets.some(w => w.address === realAddress)) {\n        throw new Error(`Wallet with address ${realAddress} already exists.`);\n      }\n\n      // Create the new wallet object (balance will be fetched separately)\n      const newWallet = {\n        id: wallets.length > 0 ? Math.max(...wallets.map(w => w.id)) + 1 : 1,\n        // Ensure unique ID\n        address: realAddress,\n        privateKey: privateKey,\n        // Still need to store this for running workflows\n        balance: null,\n        // Initialize balance as null, will be fetched\n        selected: true,\n        nickname: nickname || `Wallet ${realAddress.substring(0, 6)}...` // Default nickname\n      };\n\n      // Add wallet temporarily with null balance\n      setWallets(prevWallets => [...prevWallets, newWallet]);\n\n      // Clear form\n      setNewWalletImport({\n        privateKey: '',\n        nickname: ''\n      });\n\n      // Step 2: Fetch the balance for the new wallet\n      await fetchWalletBalance(newWallet.id, newWallet.address); // Pass ID and Address\n\n      return {\n        success: true,\n        message: 'Wallet imported successfully'\n      };\n    } catch (error) {\n      console.error('Error importing wallet:', error);\n      setWalletError(`Failed to import wallet: ${error.message}`);\n      // Optional: Remove the temporarily added wallet if fetch fails?\n      // setWallets(prevWallets => prevWallets.filter(w => w.address !== realAddress));\n      return {\n        success: false,\n        message: error.message\n      };\n    } finally {\n      setIsImportingWallet(false);\n    }\n  };\n\n  // Function to fetch all wallet balances\n  const fetchWalletBalances = async () => {\n    setIsLoadingWallets(true);\n    setWalletError(null);\n\n    // Create promises for each wallet balance fetch\n    const balancePromises = wallets.map(wallet => fetchWalletBalance(wallet.id, wallet.address) // Pass ID and address\n    );\n    try {\n      await Promise.all(balancePromises);\n      // Balances are updated directly in fetchWalletBalance via setWallets\n    } catch (error) {\n      // Errors are handled within fetchWalletBalance, maybe set a general error here?\n      console.error('Error fetching some wallet balances:', error);\n      // setWalletError(`Failed to fetch some balances: ${error.message}`); // Optional: More specific error\n    } finally {\n      setIsLoadingWallets(false);\n    }\n  };\n\n  // Function to fetch a single wallet's balance using backend API\n  const fetchWalletBalance = async (walletId, walletAddress) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/v1/get-balance/${walletAddress}`);\n      if (!response.ok) {\n        let errorMsg = `Failed to fetch balance for ${walletAddress}. Status: ${response.status}`;\n        try {\n          const errorData = await response.json();\n          errorMsg = `${errorMsg} - ${errorData.detail || 'Unknown error'}`;\n        } catch {/* Ignore */}\n        throw new Error(errorMsg);\n      }\n      const data = await response.json();\n      const balance = data.balance; // Backend now returns balance as string\n\n      // Update the specific wallet in the state\n      setWallets(prevWallets => prevWallets.map(wallet => wallet.id === walletId ? {\n        ...wallet,\n        balance: balance\n      } : wallet));\n      // Return value isn't strictly needed here as state is updated directly\n      // return { ...wallet, balance: balance }; \n    } catch (error) {\n      console.error(`Error fetching balance for wallet ${walletAddress} (ID: ${walletId}):`, error);\n      // Update the specific wallet with an error indicator or keep null balance\n      setWallets(prevWallets => prevWallets.map(wallet => wallet.id === walletId ? {\n        ...wallet,\n        balance: 'Error'\n      } // Indicate error fetching balance\n      : wallet));\n      // Propagate the error for potential handling in fetchWalletBalances\n      throw error; // Allow Promise.all in fetchWalletBalances to catch it\n    }\n  };\n\n  // Function to fetch tasks from API\n  const fetchTasks = async () => {\n    setIsLoadingTasks(true);\n    setTaskError(null);\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/v1/tasks`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      // Process and format the tasks data\n      const tasksData = Object.entries(data.tasks || {}).map(([id, task]) => ({\n        id,\n        ...task,\n        startTime: new Date(task.start_time),\n        steps: task.steps || []\n      }));\n\n      // Sort by start time, newest first\n      tasksData.sort((a, b) => b.startTime - a.startTime);\n      setTasks(tasksData);\n    } catch (error) {\n      console.error(\"Failed to fetch tasks:\", error);\n      setTaskError(`Error fetching tasks: ${error.message}`);\n      setTasks([]);\n    } finally {\n      setIsLoadingTasks(false);\n    }\n  };\n\n  // Function to run a workflow via the API\n  const runWorkflow = async () => {\n    if (!selectedWorkflow || selectedWallets.length === 0) {\n      return {\n        success: false,\n        message: \"No workflow selected or no wallets selected\"\n      };\n    }\n    try {\n      // Default payload structure\n      let payloadData = {\n        private_keys: selectedWallets.map(w => w.privateKey),\n        delay_between_keys_seconds: 30,\n        // Default delay, can be adjusted\n        // delay_between_cycles_seconds might not be used by all workflows\n        task_description: `${selectedWorkflow.name} (Manual run)`\n      };\n      let endpoint = '';\n\n      // --- Determine endpoint and specific payload based on workflow type --- //\n      switch (selectedWorkflow.type) {\n        case 'stake':\n          endpoint = '/api/v1/start-stake-cycle';\n          payloadData = {\n            ...payloadData,\n            contract_type: selectedWorkflow.contractType || 'kitsu',\n            amount_mon: 0.01,\n            // Default small amount for stake\n            cycles: 1,\n            // Default cycles\n            mode: 'random',\n            // Default mode for stake\n            tx_count: 1\n          };\n          break;\n        case 'deploy':\n          endpoint = '/api/v1/start-deploy';\n          payloadData = {\n            ...payloadData,\n            contract_name: selectedWorkflow.contractType || 'Counter',\n            // Use contractType field if available\n            contract_symbol: 'CNT',\n            // Example symbol, maybe make dynamic later\n            cycles: 1\n          };\n          break;\n        case 'swap':\n          // Assuming Uniswap for now\n          endpoint = '/api/v1/start-swap';\n          payloadData = {\n            ...payloadData,\n            token_from_symbol: selectedWorkflow.fromToken || 'ETH',\n            token_to_symbol: selectedWorkflow.toToken || 'USDC',\n            amount_str: '0.001',\n            // Default small amount for swap\n            cycles: 1,\n            mode: 'manual'\n          };\n          break;\n        case 'send':\n          endpoint = '/api/v1/start-send';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.001,\n            // Default small amount for send\n            tx_count: 1,\n            mode: selectedWorkflow.mode || 'random'\n            // recipient_address: null // Needs UI input if mode is 'single'\n          };\n          break;\n\n        // --- NEW: Bebop Case --- //\n        case 'bebop':\n          endpoint = '/api/v1/start-bebop';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.01 // Default amount to wrap/unwrap, adjust as needed\n            // Cycles not used by this specific task\n          };\n          break;\n\n        // --- NEW: Izumi Case --- //\n        case 'izumi':\n          endpoint = '/api/v1/start-izumi';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.01 // Default amount, same as bebop for now\n          };\n          break;\n\n        // --- NEW: Lilchogstars Case --- //\n        case 'lilchogstars':\n          endpoint = '/api/v1/start-lilchogstars';\n          payloadData = {\n            ...payloadData,\n            quantity: 1 // Default to minting 1 NFT per run\n          };\n          break;\n\n        // --- NEW: Mono Case --- //\n        case 'mono':\n          endpoint = '/api/v1/start-mono';\n          // No specific payload needed beyond BaseBotRequest for now\n          payloadData = {\n            ...payloadData\n          };\n          break;\n\n        // --- NEW: Rubic Case --- //\n        case 'rubic':\n          endpoint = '/api/v1/start-rubic';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.01 // Default amount for Rubic swap\n          };\n          break;\n\n        // --- NEW: Ambient Case --- //\n        case 'ambient':\n          endpoint = '/api/v1/start-ambient';\n          payloadData = {\n            ...payloadData,\n            token_in_symbol: null,\n            // Let backend choose random\n            token_out_symbol: null,\n            // Let backend choose random\n            amount_percent: 100.0 // Swap 100% of chosen token_in\n          };\n          break;\n\n        // --- NEW: Apriori Case --- //\n        case 'apriori':\n          endpoint = '/api/v1/start-apriori';\n          // No specific payload needed for the full cycle yet\n          payloadData = {\n            ...payloadData\n          };\n          break;\n\n        // --- NEW: Bean Case --- //\n        case 'bean':\n          endpoint = '/api/v1/start-bean';\n          payloadData = {\n            ...payloadData,\n            direction: 'to_token',\n            token_symbol: 'USDC',\n            amount: 0.001\n          };\n          break;\n\n        // --- NEW: Bima Case --- //\n        case 'bima':\n          endpoint = '/api/v1/start-bima';\n          payloadData = {\n            ...payloadData\n            // percent_to_lend: [20.0, 30.0] // Keep commented out to use backend default\n          };\n          break;\n        default:\n          return {\n            success: false,\n            message: `Unsupported workflow type: ${selectedWorkflow.type}`\n          };\n      }\n\n      // Make the API call to run the workflow\n      const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payloadData)\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({\n          detail: response.statusText\n        }));\n        throw new Error(`API error ${response.status}: ${errorData.detail || 'Unknown error'}`);\n      }\n      const result = await response.json();\n\n      // Refresh the tasks list after starting a new one\n      await fetchTasks();\n      return {\n        success: true,\n        message: \"Workflow started successfully\",\n        data: result\n      };\n    } catch (error) {\n      console.error(\"Error running workflow:\", error);\n      return {\n        success: false,\n        message: `Failed to run workflow: ${error.message}`\n      };\n    }\n  };\n\n  // Fetch tasks and wallet balances when component mounts\n  useEffect(() => {\n    fetchTasks();\n    // Fetch balances only if wallets exist, or maybe fetch empty\n    if (wallets.length > 0) {\n      fetchWalletBalances();\n    }\n\n    // Set up polling intervals\n    const tasksInterval = setInterval(fetchTasks, 10000); // Refresh tasks every 10 seconds\n    const walletsInterval = setInterval(fetchWalletBalances, 30000); // Refresh wallets every 30 seconds\n\n    return () => {\n      clearInterval(tasksInterval);\n      clearInterval(walletsInterval);\n    }; // Clean up on unmount\n  }, []); // Rerun if fetchWalletBalances identity changes? No, it's stable.\n\n  // Update newWalletImport state\n  const handleWalletImportChange = (field, value) => {\n    setNewWalletImport({\n      ...newWalletImport,\n      [field]: value\n    });\n  };\n\n  // The context value that will be passed to consumers\n  const contextValue = {\n    workflows,\n    selectedWorkflow,\n    selectedWorkflowId,\n    selectWorkflow,\n    wallets,\n    toggleWalletSelection,\n    selectedWallets,\n    tasks,\n    isLoadingTasks,\n    taskError,\n    fetchTasks,\n    runWorkflow,\n    // New wallet functions\n    isLoadingWallets,\n    walletError,\n    fetchWalletBalances,\n    importWallet,\n    isImportingWallet,\n    newWalletImport,\n    handleWalletImportChange\n  };\n  return /*#__PURE__*/_jsxDEV(AppContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 464,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the app context\n_s(AppProvider, \"zPjxDUjCODScqc8fz5HLuKshHy4=\");\n_c = AppProvider;\nexport const useAppContext = () => {\n  _s2();\n  const context = useContext(AppContext);\n  if (context === undefined) {\n    throw new Error('useAppContext must be used within an AppProvider');\n  }\n  return context;\n};\n_s2(useAppContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default AppContext;\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","v4","uuidv4","jsxDEV","_jsxDEV","API_BASE_URL","process","env","REACT_APP_API_BASE_URL","MOCK_WORKFLOWS","id","name","type","contractType","steps","fromToken","toToken","mode","AppContext","AppProvider","children","_s","workflows","setWorkflows","selectedWorkflowId","setSelectedWorkflowId","wallets","setWallets","isLoadingWallets","setIsLoadingWallets","walletError","setWalletError","isImportingWallet","setIsImportingWallet","newWalletImport","setNewWalletImport","privateKey","nickname","tasks","setTasks","isLoadingTasks","setIsLoadingTasks","taskError","setTaskError","selectedWorkflow","find","w","selectedWallets","filter","selected","selectWorkflow","toggleWalletSelection","map","wallet","importWallet","startsWith","length","Error","addressResponse","fetch","method","headers","body","JSON","stringify","private_key","ok","errorMsg","errorData","json","detail","addressData","realAddress","address","some","newWallet","Math","max","balance","substring","prevWallets","fetchWalletBalance","success","message","error","console","fetchWalletBalances","balancePromises","Promise","all","walletId","walletAddress","response","status","data","fetchTasks","tasksData","Object","entries","task","startTime","Date","start_time","sort","a","b","runWorkflow","payloadData","private_keys","delay_between_keys_seconds","task_description","endpoint","contract_type","amount_mon","cycles","tx_count","contract_name","contract_symbol","token_from_symbol","token_to_symbol","amount_str","quantity","token_in_symbol","token_out_symbol","amount_percent","direction","token_symbol","amount","catch","statusText","result","tasksInterval","setInterval","walletsInterval","clearInterval","handleWalletImportChange","field","value","contextValue","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAppContext","_s2","context","undefined","$RefreshReg$"],"sources":["C:/Users/cymst/Documents/monad bot/frontend/src/context/AppContext.js"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect } from 'react';\nimport { v4 as uuidv4 } from 'uuid'; // Import UUID for step IDs\n\n// Define API base URL - same as in the original LogsPage.js\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';\n\n// Mock data for workflows (to be replaced by API data eventually)\nconst MOCK_WORKFLOWS = [\n  { id: 1, name: 'Kitsu Stake', type: 'stake', contractType: 'kitsu', steps: [] },\n  { id: 2, name: 'NFT Minter (Counter)', type: 'deploy', contractType: 'counter', steps: [] },\n  { id: 3, name: 'Uniswap Swap', type: 'swap', fromToken: 'ETH', toToken: 'USDC', steps: [] },\n  { id: 4, name: 'Send MON', type: 'send', mode: 'random', steps: [] },\n  { id: 5, name: 'Bebop Wrap/Unwrap', type: 'bebop', steps: [] },\n  { id: 6, name: 'Izumi Wrap/Unwrap', type: 'izumi', steps: [] },\n  { id: 7, name: 'Lilchogstars Mint', type: 'lilchogstars', steps: [] },\n  { id: 8, name: 'Mono Transaction', type: 'mono', steps: [] },\n  { id: 9, name: 'Rubic Swap MON->USDT', type: 'rubic', steps: [] },\n  { id: 10, name: 'Ambient Swap (Random)', type: 'ambient', steps: [] },\n  { id: 11, name: 'Apriori Full Cycle', type: 'apriori', steps: [] },\n  { id: 12, name: 'Bean Swap (MON->USDC)', type: 'bean', steps: [] },\n  { id: 13, name: 'Bima Lend', type: 'bima', steps: [] }\n];\n\n// Create the context\nconst AppContext = createContext();\n\n// Provider component that wraps the app\nexport const AppProvider = ({ children }) => {\n  // Workflows state\n  const [workflows, setWorkflows] = useState(MOCK_WORKFLOWS);\n  const [selectedWorkflowId, setSelectedWorkflowId] = useState(2); // Default to NFT Minter\n  \n  // Wallets state - starts empty now\n  const [wallets, setWallets] = useState([]);\n  \n  // Wallet loading state\n  const [isLoadingWallets, setIsLoadingWallets] = useState(false);\n  const [walletError, setWalletError] = useState(null);\n  const [isImportingWallet, setIsImportingWallet] = useState(false);\n  \n  // New wallet import form state\n  const [newWalletImport, setNewWalletImport] = useState({\n    privateKey: '',\n    nickname: ''\n  });\n\n  // Tasks/runs state - will be fetched from API\n  const [tasks, setTasks] = useState([]);\n  const [isLoadingTasks, setIsLoadingTasks] = useState(false);\n  const [taskError, setTaskError] = useState(null);\n  \n  // Get the selected workflow\n  const selectedWorkflow = workflows.find(w => w.id === selectedWorkflowId) || workflows[0];\n  \n  // Get selected wallets (for running workflows)\n  const selectedWallets = wallets.filter(w => w.selected);\n  \n  // Function to select a workflow\n  const selectWorkflow = (id) => {\n    setSelectedWorkflowId(id);\n  };\n  \n  // Function to toggle wallet selection\n  const toggleWalletSelection = (id) => {\n    setWallets(wallets.map(wallet => \n      wallet.id === id ? { ...wallet, selected: !wallet.selected } : wallet\n    ));\n  };\n  \n  // Function to import a new wallet using backend API\n  const importWallet = async (privateKey, nickname = '') => {\n    setIsImportingWallet(true);\n    setWalletError(null);\n    \n    try {\n      // Basic frontend validation (backend validates format too)\n      if (!privateKey.startsWith('0x') || privateKey.length !== 66) {\n        throw new Error('Invalid private key format (must be 0x followed by 64 hex chars)');\n      }\n      \n      // Step 1: Call backend to get the real address from the private key\n      const addressResponse = await fetch(`${API_BASE_URL}/api/v1/get-address-from-key`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ private_key: privateKey }),\n      });\n\n      if (!addressResponse.ok) {\n        let errorMsg = 'Failed to derive address from key.';\n        try {\n            const errorData = await addressResponse.json();\n            errorMsg = errorData.detail || errorMsg;\n        } catch { /* Ignore if response body is not JSON */ }\n        throw new Error(errorMsg);\n      }\n\n      const addressData = await addressResponse.json();\n      const realAddress = addressData.address;\n\n      // Check if wallet with this address already exists\n      if (wallets.some(w => w.address === realAddress)) {\n        throw new Error(`Wallet with address ${realAddress} already exists.`);\n      }\n\n      // Create the new wallet object (balance will be fetched separately)\n      const newWallet = {\n        id: wallets.length > 0 ? Math.max(...wallets.map(w => w.id)) + 1 : 1, // Ensure unique ID\n        address: realAddress,\n        privateKey: privateKey, // Still need to store this for running workflows\n        balance: null, // Initialize balance as null, will be fetched\n        selected: true,\n        nickname: nickname || `Wallet ${realAddress.substring(0, 6)}...` // Default nickname\n      };\n      \n      // Add wallet temporarily with null balance\n      setWallets(prevWallets => [...prevWallets, newWallet]);\n      \n      // Clear form\n      setNewWalletImport({ privateKey: '', nickname: '' });\n      \n      // Step 2: Fetch the balance for the new wallet\n      await fetchWalletBalance(newWallet.id, newWallet.address); // Pass ID and Address\n      \n      return { success: true, message: 'Wallet imported successfully' };\n\n    } catch (error) {\n      console.error('Error importing wallet:', error);\n      setWalletError(`Failed to import wallet: ${error.message}`);\n      // Optional: Remove the temporarily added wallet if fetch fails?\n      // setWallets(prevWallets => prevWallets.filter(w => w.address !== realAddress));\n      return { success: false, message: error.message };\n    } finally {\n      setIsImportingWallet(false);\n    }\n  };\n  \n  // Function to fetch all wallet balances\n  const fetchWalletBalances = async () => {\n    setIsLoadingWallets(true);\n    setWalletError(null);\n    \n    // Create promises for each wallet balance fetch\n    const balancePromises = wallets.map(wallet => \n        fetchWalletBalance(wallet.id, wallet.address) // Pass ID and address\n    );\n\n    try {\n        await Promise.all(balancePromises);\n        // Balances are updated directly in fetchWalletBalance via setWallets\n    } catch (error) {\n        // Errors are handled within fetchWalletBalance, maybe set a general error here?\n        console.error('Error fetching some wallet balances:', error); \n        // setWalletError(`Failed to fetch some balances: ${error.message}`); // Optional: More specific error\n    } finally {\n        setIsLoadingWallets(false);\n    }\n  };\n  \n  // Function to fetch a single wallet's balance using backend API\n  const fetchWalletBalance = async (walletId, walletAddress) => {\n    try {\n        const response = await fetch(`${API_BASE_URL}/api/v1/get-balance/${walletAddress}`);\n        \n        if (!response.ok) {\n            let errorMsg = `Failed to fetch balance for ${walletAddress}. Status: ${response.status}`;\n            try {\n                const errorData = await response.json();\n                errorMsg = `${errorMsg} - ${errorData.detail || 'Unknown error'}`;\n            } catch { /* Ignore */ }\n            throw new Error(errorMsg);\n        }\n        \n        const data = await response.json();\n        const balance = data.balance; // Backend now returns balance as string\n\n        // Update the specific wallet in the state\n        setWallets(prevWallets => \n            prevWallets.map(wallet => \n                wallet.id === walletId \n                    ? { ...wallet, balance: balance } \n                    : wallet\n            )\n        );\n        // Return value isn't strictly needed here as state is updated directly\n        // return { ...wallet, balance: balance }; \n\n    } catch (error) {\n        console.error(`Error fetching balance for wallet ${walletAddress} (ID: ${walletId}):`, error);\n        // Update the specific wallet with an error indicator or keep null balance\n        setWallets(prevWallets => \n            prevWallets.map(wallet => \n                wallet.id === walletId \n                    ? { ...wallet, balance: 'Error' } // Indicate error fetching balance\n                    : wallet\n            )\n        );\n        // Propagate the error for potential handling in fetchWalletBalances\n        throw error; // Allow Promise.all in fetchWalletBalances to catch it\n    }\n  };\n  \n  // Function to fetch tasks from API\n  const fetchTasks = async () => {\n    setIsLoadingTasks(true);\n    setTaskError(null);\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/v1/tasks`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      // Process and format the tasks data\n      const tasksData = Object.entries(data.tasks || {}).map(([id, task]) => ({\n        id,\n        ...task,\n        startTime: new Date(task.start_time),\n        steps: task.steps || [],\n      }));\n      \n      // Sort by start time, newest first\n      tasksData.sort((a, b) => b.startTime - a.startTime);\n      setTasks(tasksData);\n    } catch (error) {\n      console.error(\"Failed to fetch tasks:\", error);\n      setTaskError(`Error fetching tasks: ${error.message}`);\n      setTasks([]);\n    } finally {\n      setIsLoadingTasks(false);\n    }\n  };\n  \n  // Function to run a workflow via the API\n  const runWorkflow = async () => {\n    if (!selectedWorkflow || selectedWallets.length === 0) {\n      return { success: false, message: \"No workflow selected or no wallets selected\" };\n    }\n    \n    try {\n      // Default payload structure\n      let payloadData = {\n        private_keys: selectedWallets.map(w => w.privateKey),\n        delay_between_keys_seconds: 30, // Default delay, can be adjusted\n        // delay_between_cycles_seconds might not be used by all workflows\n        task_description: `${selectedWorkflow.name} (Manual run)`\n      };\n      let endpoint = '';\n\n      // --- Determine endpoint and specific payload based on workflow type --- //\n      switch (selectedWorkflow.type) {\n        case 'stake':\n          endpoint = '/api/v1/start-stake-cycle';\n          payloadData = {\n            ...payloadData,\n            contract_type: selectedWorkflow.contractType || 'kitsu',\n            amount_mon: 0.01, // Default small amount for stake\n            cycles: 1, // Default cycles\n            mode: 'random', // Default mode for stake\n            tx_count: 1,\n          };\n          break;\n        \n        case 'deploy':\n          endpoint = '/api/v1/start-deploy';\n          payloadData = {\n            ...payloadData,\n            contract_name: selectedWorkflow.contractType || 'Counter', // Use contractType field if available\n            contract_symbol: 'CNT', // Example symbol, maybe make dynamic later\n            cycles: 1,\n          };\n          break;\n          \n        case 'swap': // Assuming Uniswap for now\n          endpoint = '/api/v1/start-swap';\n          payloadData = {\n            ...payloadData,\n            token_from_symbol: selectedWorkflow.fromToken || 'ETH',\n            token_to_symbol: selectedWorkflow.toToken || 'USDC',\n            amount_str: '0.001', // Default small amount for swap\n            cycles: 1,\n            mode: 'manual',\n          };\n          break;\n          \n        case 'send':\n          endpoint = '/api/v1/start-send';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.001, // Default small amount for send\n            tx_count: 1,\n            mode: selectedWorkflow.mode || 'random',\n            // recipient_address: null // Needs UI input if mode is 'single'\n          };\n          break;\n\n        // --- NEW: Bebop Case --- //\n        case 'bebop':\n          endpoint = '/api/v1/start-bebop';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.01, // Default amount to wrap/unwrap, adjust as needed\n            // Cycles not used by this specific task\n          };\n          break;\n          \n        // --- NEW: Izumi Case --- //\n        case 'izumi':\n          endpoint = '/api/v1/start-izumi';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.01, // Default amount, same as bebop for now\n          };\n          break;\n          \n        // --- NEW: Lilchogstars Case --- //\n        case 'lilchogstars':\n          endpoint = '/api/v1/start-lilchogstars';\n          payloadData = {\n            ...payloadData,\n            quantity: 1, // Default to minting 1 NFT per run\n          };\n          break;\n          \n        // --- NEW: Mono Case --- //\n        case 'mono':\n          endpoint = '/api/v1/start-mono';\n          // No specific payload needed beyond BaseBotRequest for now\n          payloadData = {\n            ...payloadData,\n          };\n          break;\n          \n        // --- NEW: Rubic Case --- //\n        case 'rubic':\n          endpoint = '/api/v1/start-rubic';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.01, // Default amount for Rubic swap\n          };\n          break;\n          \n        // --- NEW: Ambient Case --- //\n        case 'ambient':\n          endpoint = '/api/v1/start-ambient';\n          payloadData = {\n            ...payloadData,\n            token_in_symbol: null, // Let backend choose random\n            token_out_symbol: null, // Let backend choose random\n            amount_percent: 100.0, // Swap 100% of chosen token_in\n          };\n          break;\n          \n        // --- NEW: Apriori Case --- //\n        case 'apriori':\n          endpoint = '/api/v1/start-apriori';\n          // No specific payload needed for the full cycle yet\n          payloadData = {\n            ...payloadData,\n          };\n          break;\n          \n        // --- NEW: Bean Case --- //\n        case 'bean':\n          endpoint = '/api/v1/start-bean';\n          payloadData = {\n            ...payloadData,\n            direction: 'to_token',\n            token_symbol: 'USDC',\n            amount: 0.001,\n          };\n          break;\n          \n        // --- NEW: Bima Case --- //\n        case 'bima':\n          endpoint = '/api/v1/start-bima';\n          payloadData = {\n            ...payloadData,\n            // percent_to_lend: [20.0, 30.0] // Keep commented out to use backend default\n          };\n          break;\n          \n        default:\n          return { success: false, message: `Unsupported workflow type: ${selectedWorkflow.type}` };\n      }\n      \n      // Make the API call to run the workflow\n      const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(payloadData),\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({ detail: response.statusText }));\n        throw new Error(`API error ${response.status}: ${errorData.detail || 'Unknown error'}`);\n      }\n      \n      const result = await response.json();\n      \n      // Refresh the tasks list after starting a new one\n      await fetchTasks();\n      \n      return { success: true, message: \"Workflow started successfully\", data: result };\n    } catch (error) {\n      console.error(\"Error running workflow:\", error);\n      return { success: false, message: `Failed to run workflow: ${error.message}` };\n    }\n  };\n  \n  // Fetch tasks and wallet balances when component mounts\n  useEffect(() => {\n    fetchTasks();\n    // Fetch balances only if wallets exist, or maybe fetch empty\n    if (wallets.length > 0) {\n        fetchWalletBalances();\n    }\n    \n    // Set up polling intervals\n    const tasksInterval = setInterval(fetchTasks, 10000); // Refresh tasks every 10 seconds\n    const walletsInterval = setInterval(fetchWalletBalances, 30000); // Refresh wallets every 30 seconds\n    \n    return () => {\n      clearInterval(tasksInterval);\n      clearInterval(walletsInterval);\n    }; // Clean up on unmount\n  }, []); // Rerun if fetchWalletBalances identity changes? No, it's stable.\n  \n  // Update newWalletImport state\n  const handleWalletImportChange = (field, value) => {\n    setNewWalletImport({\n      ...newWalletImport,\n      [field]: value\n    });\n  };\n  \n  // The context value that will be passed to consumers\n  const contextValue = {\n    workflows,\n    selectedWorkflow,\n    selectedWorkflowId,\n    selectWorkflow,\n    wallets,\n    toggleWalletSelection,\n    selectedWallets,\n    tasks,\n    isLoadingTasks,\n    taskError,\n    fetchTasks,\n    runWorkflow,\n    // New wallet functions\n    isLoadingWallets,\n    walletError,\n    fetchWalletBalances,\n    importWallet,\n    isImportingWallet,\n    newWalletImport,\n    handleWalletImportChange\n  };\n  \n  return (\n    <AppContext.Provider value={contextValue}>\n      {children}\n    </AppContext.Provider>\n  );\n};\n\n// Custom hook to use the app context\nexport const useAppContext = () => {\n  const context = useContext(AppContext);\n  if (context === undefined) {\n    throw new Error('useAppContext must be used within an AppProvider');\n  }\n  return context;\n};\n\nexport default AppContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}