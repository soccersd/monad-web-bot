{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\cymst\\\\Documents\\\\monad bot\\\\frontend\\\\src\\\\context\\\\AppContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect } from 'react';\n\n// Define API base URL - same as in the original LogsPage.js\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';\n\n// Mock data for workflows (to be replaced by API data eventually)\nconst MOCK_WORKFLOWS = [{\n  id: 1,\n  name: 'Workflow Name is Test Ja',\n  type: 'stake',\n  contractType: 'kitsu'\n}, {\n  id: 2,\n  name: 'NFT Minter workflow',\n  type: 'deploy',\n  contractType: 'counter'\n}, {\n  id: 3,\n  name: 'Workflow#5',\n  type: 'swap',\n  fromToken: 'ETH',\n  toToken: 'USDC'\n}, {\n  id: 4,\n  name: 'Token Send Workflow',\n  type: 'send',\n  mode: 'random'\n}];\n\n// Create the context\nconst AppContext = /*#__PURE__*/createContext();\n\n// Provider component that wraps the app\nexport const AppProvider = ({\n  children\n}) => {\n  _s();\n  // Workflows state\n  const [workflows, setWorkflows] = useState(MOCK_WORKFLOWS);\n  const [selectedWorkflowId, setSelectedWorkflowId] = useState(2); // Default to NFT Minter\n\n  // Wallets state - now with real balances\n  const [wallets, setWallets] = useState([]);\n\n  // Wallet loading state\n  const [isLoadingWallets, setIsLoadingWallets] = useState(false);\n  const [walletError, setWalletError] = useState(null);\n  const [isImportingWallet, setIsImportingWallet] = useState(false);\n\n  // New wallet import form state\n  const [newWalletImport, setNewWalletImport] = useState({\n    privateKey: '',\n    nickname: ''\n  });\n\n  // Tasks/runs state - will be fetched from API\n  const [tasks, setTasks] = useState([]);\n  const [isLoadingTasks, setIsLoadingTasks] = useState(false);\n  const [taskError, setTaskError] = useState(null);\n\n  // Get the selected workflow\n  const selectedWorkflow = workflows.find(w => w.id === selectedWorkflowId) || workflows[0];\n\n  // Get selected wallets (for running workflows)\n  const selectedWallets = wallets.filter(w => w.selected);\n\n  // Function to select a workflow\n  const selectWorkflow = id => {\n    setSelectedWorkflowId(id);\n  };\n\n  // Function to toggle wallet selection\n  const toggleWalletSelection = id => {\n    setWallets(wallets.map(wallet => wallet.id === id ? {\n      ...wallet,\n      selected: !wallet.selected\n    } : wallet));\n  };\n\n  // Function to import a new wallet\n  const importWallet = async (privateKey, nickname = '') => {\n    setIsImportingWallet(true);\n    setWalletError(null);\n    try {\n      // Validate private key format\n      if (!privateKey.startsWith('0x') || privateKey.length !== 66) {\n        throw new Error('Invalid private key format');\n      }\n\n      // In a real app, we would call an API to import/validate the wallet\n      // For now, we'll simulate this and derive the address using mock data\n\n      // Simulate API call delay\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      // Create a mock address from private key (in reality this would come from Web3.js)\n      const addressPart = privateKey.substring(privateKey.length - 8);\n      const mockAddress = `0x${addressPart}..${addressPart.substring(0, 4)}`;\n\n      // Add the new wallet to state\n      const newWallet = {\n        id: wallets.length + 1,\n        address: mockAddress,\n        privateKey: privateKey,\n        balance: 0,\n        // Will be updated by fetchWalletBalances\n        selected: true,\n        nickname: nickname || `Wallet ${wallets.length + 1}`\n      };\n      setWallets([...wallets, newWallet]);\n\n      // Clear form\n      setNewWalletImport({\n        privateKey: '',\n        nickname: ''\n      });\n\n      // Fetch balance for the new wallet\n      fetchWalletBalance(newWallet);\n      return {\n        success: true,\n        message: 'Wallet imported successfully'\n      };\n    } catch (error) {\n      console.error('Error importing wallet:', error);\n      setWalletError(`Failed to import wallet: ${error.message}`);\n      return {\n        success: false,\n        message: error.message\n      };\n    } finally {\n      setIsImportingWallet(false);\n    }\n  };\n\n  // Function to fetch wallet balances\n  const fetchWalletBalances = async () => {\n    setIsLoadingWallets(true);\n    setWalletError(null);\n    try {\n      // In a real app, we'd make API calls to get the balances\n      // For this demo, we'll simulate API responses with random balances\n      const updatedWallets = await Promise.all(wallets.map(async wallet => {\n        return fetchWalletBalance(wallet);\n      }));\n      setWallets(updatedWallets);\n    } catch (error) {\n      console.error('Error fetching wallet balances:', error);\n      setWalletError(`Failed to fetch wallet balances: ${error.message}`);\n    } finally {\n      setIsLoadingWallets(false);\n    }\n  };\n\n  // Function to fetch a single wallet's balance\n  const fetchWalletBalance = async wallet => {\n    try {\n      // In a production app, make a real API call to get the balance\n      // For now, simulate a balance check API\n\n      // Try to check the backend for wallet balance info using the first few characters\n      // of the private key as a dummy identifier\n      const response = await fetch(`${API_BASE_URL}/api/v1/wallet-balance?address=${wallet.address}`);\n\n      // If the request fails, generate a random balance\n      if (!response.ok) {\n        // Generate a random balance between 0.1 and 15 MON\n        const randomBalance = Math.random() * 15 + 0.1;\n        return {\n          ...wallet,\n          balance: randomBalance\n        };\n      }\n\n      // Parse the response\n      const data = await response.json();\n\n      // Update the wallet with the real balance\n      return {\n        ...wallet,\n        balance: data.balance || Math.random() * 15 + 0.1 // Fallback to random if API doesn't provide\n      };\n    } catch (error) {\n      console.error(`Error fetching balance for wallet ${wallet.address}:`, error);\n      // Return the wallet with unchanged balance in case of error\n      return wallet;\n    }\n  };\n\n  // Function to fetch tasks from API\n  const fetchTasks = async () => {\n    setIsLoadingTasks(true);\n    setTaskError(null);\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/v1/tasks`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      // Process and format the tasks data\n      const tasksData = Object.entries(data.tasks || {}).map(([id, task]) => ({\n        id,\n        ...task,\n        startTime: new Date(task.start_time)\n      }));\n\n      // Sort by start time, newest first\n      tasksData.sort((a, b) => b.startTime - a.startTime);\n      setTasks(tasksData);\n    } catch (error) {\n      console.error(\"Failed to fetch tasks:\", error);\n      setTaskError(`Error fetching tasks: ${error.message}`);\n      setTasks([]);\n    } finally {\n      setIsLoadingTasks(false);\n    }\n  };\n\n  // Function to run a workflow via the API\n  const runWorkflow = async () => {\n    if (!selectedWorkflow || selectedWallets.length === 0) {\n      return {\n        success: false,\n        message: \"No workflow selected or no wallets selected\"\n      };\n    }\n    try {\n      // Depending on the workflow type, call different API endpoints\n      let endpoint = '';\n      let payloadData = {\n        private_keys: selectedWallets.map(w => w.privateKey),\n        delay_between_keys_seconds: 30,\n        delay_between_cycles_seconds: 60,\n        task_description: `${selectedWorkflow.name} (Manual run)`\n      };\n      switch (selectedWorkflow.type) {\n        case 'stake':\n          endpoint = '/api/v1/start-stake-cycle';\n          payloadData = {\n            ...payloadData,\n            contract_type: selectedWorkflow.contractType || 'kitsu',\n            amount_mon: 0.01,\n            // Default small amount\n            cycles: 1,\n            mode: 'random',\n            tx_count: 1\n          };\n          break;\n        case 'deploy':\n          endpoint = '/api/v1/start-deploy';\n          payloadData = {\n            ...payloadData,\n            contract_name: 'Counter',\n            contract_symbol: 'CNT',\n            cycles: 1\n          };\n          break;\n        case 'swap':\n          endpoint = '/api/v1/start-swap';\n          payloadData = {\n            ...payloadData,\n            token_from_symbol: selectedWorkflow.fromToken || 'ETH',\n            token_to_symbol: selectedWorkflow.toToken || 'USDC',\n            amount_str: '0.001',\n            cycles: 1,\n            mode: 'manual'\n          };\n          break;\n        case 'send':\n          endpoint = '/api/v1/start-send';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.001,\n            tx_count: 1,\n            mode: selectedWorkflow.mode || 'random'\n          };\n          break;\n        default:\n          return {\n            success: false,\n            message: `Unsupported workflow type: ${selectedWorkflow.type}`\n          };\n      }\n\n      // Make the API call to run the workflow\n      const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payloadData)\n      });\n      if (!response.ok) {\n        throw new Error(`API error: ${response.status}`);\n      }\n      const result = await response.json();\n\n      // Refresh the tasks list after starting a new one\n      await fetchTasks();\n      return {\n        success: true,\n        message: \"Workflow started successfully\",\n        data: result\n      };\n    } catch (error) {\n      console.error(\"Error running workflow:\", error);\n      return {\n        success: false,\n        message: `Failed to run workflow: ${error.message}`\n      };\n    }\n  };\n\n  // Fetch tasks and wallet balances when component mounts\n  useEffect(() => {\n    fetchTasks();\n    fetchWalletBalances();\n\n    // Set up polling intervals\n    const tasksInterval = setInterval(fetchTasks, 10000); // Refresh tasks every 10 seconds\n    const walletsInterval = setInterval(fetchWalletBalances, 30000); // Refresh wallets every 30 seconds\n\n    return () => {\n      clearInterval(tasksInterval);\n      clearInterval(walletsInterval);\n    }; // Clean up on unmount\n  }, []);\n\n  // Update newWalletImport state\n  const handleWalletImportChange = (field, value) => {\n    setNewWalletImport({\n      ...newWalletImport,\n      [field]: value\n    });\n  };\n\n  // The context value that will be passed to consumers\n  const contextValue = {\n    workflows,\n    selectedWorkflow,\n    selectedWorkflowId,\n    selectWorkflow,\n    wallets,\n    toggleWalletSelection,\n    selectedWallets,\n    tasks,\n    isLoadingTasks,\n    taskError,\n    fetchTasks,\n    runWorkflow,\n    // New wallet functions\n    isLoadingWallets,\n    walletError,\n    fetchWalletBalances,\n    importWallet,\n    isImportingWallet,\n    newWalletImport,\n    handleWalletImportChange\n  };\n  return /*#__PURE__*/_jsxDEV(AppContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 335,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the app context\n_s(AppProvider, \"Jr0Hhyx6+Ypk67ETpqcQPdB7xto=\");\n_c = AppProvider;\nexport const useAppContext = () => {\n  _s2();\n  const context = useContext(AppContext);\n  if (context === undefined) {\n    throw new Error('useAppContext must be used within an AppProvider');\n  }\n  return context;\n};\n_s2(useAppContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default AppContext;\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","jsxDEV","_jsxDEV","API_BASE_URL","process","env","REACT_APP_API_BASE_URL","MOCK_WORKFLOWS","id","name","type","contractType","fromToken","toToken","mode","AppContext","AppProvider","children","_s","workflows","setWorkflows","selectedWorkflowId","setSelectedWorkflowId","wallets","setWallets","isLoadingWallets","setIsLoadingWallets","walletError","setWalletError","isImportingWallet","setIsImportingWallet","newWalletImport","setNewWalletImport","privateKey","nickname","tasks","setTasks","isLoadingTasks","setIsLoadingTasks","taskError","setTaskError","selectedWorkflow","find","w","selectedWallets","filter","selected","selectWorkflow","toggleWalletSelection","map","wallet","importWallet","startsWith","length","Error","Promise","resolve","setTimeout","addressPart","substring","mockAddress","newWallet","address","balance","fetchWalletBalance","success","message","error","console","fetchWalletBalances","updatedWallets","all","response","fetch","ok","randomBalance","Math","random","data","json","fetchTasks","status","tasksData","Object","entries","task","startTime","Date","start_time","sort","a","b","runWorkflow","endpoint","payloadData","private_keys","delay_between_keys_seconds","delay_between_cycles_seconds","task_description","contract_type","amount_mon","cycles","tx_count","contract_name","contract_symbol","token_from_symbol","token_to_symbol","amount_str","method","headers","body","JSON","stringify","result","tasksInterval","setInterval","walletsInterval","clearInterval","handleWalletImportChange","field","value","contextValue","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAppContext","_s2","context","undefined","$RefreshReg$"],"sources":["C:/Users/cymst/Documents/monad bot/frontend/src/context/AppContext.js"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect } from 'react';\r\n\r\n// Define API base URL - same as in the original LogsPage.js\r\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';\r\n\r\n// Mock data for workflows (to be replaced by API data eventually)\r\nconst MOCK_WORKFLOWS = [\r\n  { id: 1, name: 'Workflow Name is Test Ja', type: 'stake', contractType: 'kitsu' },\r\n  { id: 2, name: 'NFT Minter workflow', type: 'deploy', contractType: 'counter' },\r\n  { id: 3, name: 'Workflow#5', type: 'swap', fromToken: 'ETH', toToken: 'USDC' },\r\n  { id: 4, name: 'Token Send Workflow', type: 'send', mode: 'random' },\r\n];\r\n\r\n// Create the context\r\nconst AppContext = createContext();\r\n\r\n// Provider component that wraps the app\r\nexport const AppProvider = ({ children }) => {\r\n  // Workflows state\r\n  const [workflows, setWorkflows] = useState(MOCK_WORKFLOWS);\r\n  const [selectedWorkflowId, setSelectedWorkflowId] = useState(2); // Default to NFT Minter\r\n  \r\n  // Wallets state - now with real balances\r\n  const [wallets, setWallets] = useState([]);\r\n  \r\n  // Wallet loading state\r\n  const [isLoadingWallets, setIsLoadingWallets] = useState(false);\r\n  const [walletError, setWalletError] = useState(null);\r\n  const [isImportingWallet, setIsImportingWallet] = useState(false);\r\n  \r\n  // New wallet import form state\r\n  const [newWalletImport, setNewWalletImport] = useState({\r\n    privateKey: '',\r\n    nickname: ''\r\n  });\r\n\r\n  // Tasks/runs state - will be fetched from API\r\n  const [tasks, setTasks] = useState([]);\r\n  const [isLoadingTasks, setIsLoadingTasks] = useState(false);\r\n  const [taskError, setTaskError] = useState(null);\r\n  \r\n  // Get the selected workflow\r\n  const selectedWorkflow = workflows.find(w => w.id === selectedWorkflowId) || workflows[0];\r\n  \r\n  // Get selected wallets (for running workflows)\r\n  const selectedWallets = wallets.filter(w => w.selected);\r\n  \r\n  // Function to select a workflow\r\n  const selectWorkflow = (id) => {\r\n    setSelectedWorkflowId(id);\r\n  };\r\n  \r\n  // Function to toggle wallet selection\r\n  const toggleWalletSelection = (id) => {\r\n    setWallets(wallets.map(wallet => \r\n      wallet.id === id ? { ...wallet, selected: !wallet.selected } : wallet\r\n    ));\r\n  };\r\n  \r\n  // Function to import a new wallet\r\n  const importWallet = async (privateKey, nickname = '') => {\r\n    setIsImportingWallet(true);\r\n    setWalletError(null);\r\n    \r\n    try {\r\n      // Validate private key format\r\n      if (!privateKey.startsWith('0x') || privateKey.length !== 66) {\r\n        throw new Error('Invalid private key format');\r\n      }\r\n      \r\n      // In a real app, we would call an API to import/validate the wallet\r\n      // For now, we'll simulate this and derive the address using mock data\r\n      \r\n      // Simulate API call delay\r\n      await new Promise(resolve => setTimeout(resolve, 1000));\r\n      \r\n      // Create a mock address from private key (in reality this would come from Web3.js)\r\n      const addressPart = privateKey.substring(privateKey.length - 8);\r\n      const mockAddress = `0x${addressPart}..${addressPart.substring(0, 4)}`;\r\n      \r\n      // Add the new wallet to state\r\n      const newWallet = {\r\n        id: wallets.length + 1,\r\n        address: mockAddress,\r\n        privateKey: privateKey,\r\n        balance: 0, // Will be updated by fetchWalletBalances\r\n        selected: true,\r\n        nickname: nickname || `Wallet ${wallets.length + 1}`\r\n      };\r\n      \r\n      setWallets([...wallets, newWallet]);\r\n      \r\n      // Clear form\r\n      setNewWalletImport({\r\n        privateKey: '',\r\n        nickname: ''\r\n      });\r\n      \r\n      // Fetch balance for the new wallet\r\n      fetchWalletBalance(newWallet);\r\n      \r\n      return { success: true, message: 'Wallet imported successfully' };\r\n    } catch (error) {\r\n      console.error('Error importing wallet:', error);\r\n      setWalletError(`Failed to import wallet: ${error.message}`);\r\n      return { success: false, message: error.message };\r\n    } finally {\r\n      setIsImportingWallet(false);\r\n    }\r\n  };\r\n  \r\n  // Function to fetch wallet balances\r\n  const fetchWalletBalances = async () => {\r\n    setIsLoadingWallets(true);\r\n    setWalletError(null);\r\n    \r\n    try {\r\n      // In a real app, we'd make API calls to get the balances\r\n      // For this demo, we'll simulate API responses with random balances\r\n      const updatedWallets = await Promise.all(wallets.map(async wallet => {\r\n        return fetchWalletBalance(wallet);\r\n      }));\r\n      \r\n      setWallets(updatedWallets);\r\n    } catch (error) {\r\n      console.error('Error fetching wallet balances:', error);\r\n      setWalletError(`Failed to fetch wallet balances: ${error.message}`);\r\n    } finally {\r\n      setIsLoadingWallets(false);\r\n    }\r\n  };\r\n  \r\n  // Function to fetch a single wallet's balance\r\n  const fetchWalletBalance = async (wallet) => {\r\n    try {\r\n      // In a production app, make a real API call to get the balance\r\n      // For now, simulate a balance check API\r\n      \r\n      // Try to check the backend for wallet balance info using the first few characters\r\n      // of the private key as a dummy identifier\r\n      const response = await fetch(`${API_BASE_URL}/api/v1/wallet-balance?address=${wallet.address}`);\r\n      \r\n      // If the request fails, generate a random balance\r\n      if (!response.ok) {\r\n        // Generate a random balance between 0.1 and 15 MON\r\n        const randomBalance = Math.random() * 15 + 0.1;\r\n        return {\r\n          ...wallet,\r\n          balance: randomBalance\r\n        };\r\n      }\r\n      \r\n      // Parse the response\r\n      const data = await response.json();\r\n      \r\n      // Update the wallet with the real balance\r\n      return {\r\n        ...wallet,\r\n        balance: data.balance || Math.random() * 15 + 0.1 // Fallback to random if API doesn't provide\r\n      };\r\n    } catch (error) {\r\n      console.error(`Error fetching balance for wallet ${wallet.address}:`, error);\r\n      // Return the wallet with unchanged balance in case of error\r\n      return wallet;\r\n    }\r\n  };\r\n  \r\n  // Function to fetch tasks from API\r\n  const fetchTasks = async () => {\r\n    setIsLoadingTasks(true);\r\n    setTaskError(null);\r\n    try {\r\n      const response = await fetch(`${API_BASE_URL}/api/v1/tasks`);\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      const data = await response.json();\r\n      // Process and format the tasks data\r\n      const tasksData = Object.entries(data.tasks || {}).map(([id, task]) => ({\r\n        id,\r\n        ...task,\r\n        startTime: new Date(task.start_time),\r\n      }));\r\n      \r\n      // Sort by start time, newest first\r\n      tasksData.sort((a, b) => b.startTime - a.startTime);\r\n      setTasks(tasksData);\r\n    } catch (error) {\r\n      console.error(\"Failed to fetch tasks:\", error);\r\n      setTaskError(`Error fetching tasks: ${error.message}`);\r\n      setTasks([]);\r\n    } finally {\r\n      setIsLoadingTasks(false);\r\n    }\r\n  };\r\n  \r\n  // Function to run a workflow via the API\r\n  const runWorkflow = async () => {\r\n    if (!selectedWorkflow || selectedWallets.length === 0) {\r\n      return { success: false, message: \"No workflow selected or no wallets selected\" };\r\n    }\r\n    \r\n    try {\r\n      // Depending on the workflow type, call different API endpoints\r\n      let endpoint = '';\r\n      let payloadData = {\r\n        private_keys: selectedWallets.map(w => w.privateKey),\r\n        delay_between_keys_seconds: 30,\r\n        delay_between_cycles_seconds: 60,\r\n        task_description: `${selectedWorkflow.name} (Manual run)`\r\n      };\r\n      \r\n      switch (selectedWorkflow.type) {\r\n        case 'stake':\r\n          endpoint = '/api/v1/start-stake-cycle';\r\n          payloadData = {\r\n            ...payloadData,\r\n            contract_type: selectedWorkflow.contractType || 'kitsu',\r\n            amount_mon: 0.01, // Default small amount\r\n            cycles: 1,\r\n            mode: 'random',\r\n            tx_count: 1,\r\n          };\r\n          break;\r\n        \r\n        case 'deploy':\r\n          endpoint = '/api/v1/start-deploy';\r\n          payloadData = {\r\n            ...payloadData,\r\n            contract_name: 'Counter',\r\n            contract_symbol: 'CNT',\r\n            cycles: 1,\r\n          };\r\n          break;\r\n          \r\n        case 'swap':\r\n          endpoint = '/api/v1/start-swap';\r\n          payloadData = {\r\n            ...payloadData,\r\n            token_from_symbol: selectedWorkflow.fromToken || 'ETH',\r\n            token_to_symbol: selectedWorkflow.toToken || 'USDC',\r\n            amount_str: '0.001',\r\n            cycles: 1,\r\n            mode: 'manual',\r\n          };\r\n          break;\r\n          \r\n        case 'send':\r\n          endpoint = '/api/v1/start-send';\r\n          payloadData = {\r\n            ...payloadData,\r\n            amount_mon: 0.001,\r\n            tx_count: 1,\r\n            mode: selectedWorkflow.mode || 'random',\r\n          };\r\n          break;\r\n          \r\n        default:\r\n          return { success: false, message: `Unsupported workflow type: ${selectedWorkflow.type}` };\r\n      }\r\n      \r\n      // Make the API call to run the workflow\r\n      const response = await fetch(`${API_BASE_URL}${endpoint}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(payloadData),\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`API error: ${response.status}`);\r\n      }\r\n      \r\n      const result = await response.json();\r\n      \r\n      // Refresh the tasks list after starting a new one\r\n      await fetchTasks();\r\n      \r\n      return { success: true, message: \"Workflow started successfully\", data: result };\r\n    } catch (error) {\r\n      console.error(\"Error running workflow:\", error);\r\n      return { success: false, message: `Failed to run workflow: ${error.message}` };\r\n    }\r\n  };\r\n  \r\n  // Fetch tasks and wallet balances when component mounts\r\n  useEffect(() => {\r\n    fetchTasks();\r\n    fetchWalletBalances();\r\n    \r\n    // Set up polling intervals\r\n    const tasksInterval = setInterval(fetchTasks, 10000); // Refresh tasks every 10 seconds\r\n    const walletsInterval = setInterval(fetchWalletBalances, 30000); // Refresh wallets every 30 seconds\r\n    \r\n    return () => {\r\n      clearInterval(tasksInterval);\r\n      clearInterval(walletsInterval);\r\n    }; // Clean up on unmount\r\n  }, []);\r\n  \r\n  // Update newWalletImport state\r\n  const handleWalletImportChange = (field, value) => {\r\n    setNewWalletImport({\r\n      ...newWalletImport,\r\n      [field]: value\r\n    });\r\n  };\r\n  \r\n  // The context value that will be passed to consumers\r\n  const contextValue = {\r\n    workflows,\r\n    selectedWorkflow,\r\n    selectedWorkflowId,\r\n    selectWorkflow,\r\n    wallets,\r\n    toggleWalletSelection,\r\n    selectedWallets,\r\n    tasks,\r\n    isLoadingTasks,\r\n    taskError,\r\n    fetchTasks,\r\n    runWorkflow,\r\n    // New wallet functions\r\n    isLoadingWallets,\r\n    walletError,\r\n    fetchWalletBalances,\r\n    importWallet,\r\n    isImportingWallet,\r\n    newWalletImport,\r\n    handleWalletImportChange\r\n  };\r\n  \r\n  return (\r\n    <AppContext.Provider value={contextValue}>\r\n      {children}\r\n    </AppContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook to use the app context\r\nexport const useAppContext = () => {\r\n  const context = useContext(AppContext);\r\n  if (context === undefined) {\r\n    throw new Error('useAppContext must be used within an AppProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\nexport default AppContext;"],"mappings":";;;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,SAAS,QAAQ,OAAO;;AAE7E;AAAA,SAAAC,MAAA,IAAAC,OAAA;AACA,MAAMC,YAAY,GAAGC,OAAO,CAACC,GAAG,CAACC,sBAAsB,IAAI,uBAAuB;;AAElF;AACA,MAAMC,cAAc,GAAG,CACrB;EAAEC,EAAE,EAAE,CAAC;EAAEC,IAAI,EAAE,0BAA0B;EAAEC,IAAI,EAAE,OAAO;EAAEC,YAAY,EAAE;AAAQ,CAAC,EACjF;EAAEH,EAAE,EAAE,CAAC;EAAEC,IAAI,EAAE,qBAAqB;EAAEC,IAAI,EAAE,QAAQ;EAAEC,YAAY,EAAE;AAAU,CAAC,EAC/E;EAAEH,EAAE,EAAE,CAAC;EAAEC,IAAI,EAAE,YAAY;EAAEC,IAAI,EAAE,MAAM;EAAEE,SAAS,EAAE,KAAK;EAAEC,OAAO,EAAE;AAAO,CAAC,EAC9E;EAAEL,EAAE,EAAE,CAAC;EAAEC,IAAI,EAAE,qBAAqB;EAAEC,IAAI,EAAE,MAAM;EAAEI,IAAI,EAAE;AAAS,CAAC,CACrE;;AAED;AACA,MAAMC,UAAU,gBAAGlB,aAAa,CAAC,CAAC;;AAElC;AACA,OAAO,MAAMmB,WAAW,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EAC3C;EACA,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGtB,QAAQ,CAACS,cAAc,CAAC;EAC1D,MAAM,CAACc,kBAAkB,EAAEC,qBAAqB,CAAC,GAAGxB,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;;EAEjE;EACA,MAAM,CAACyB,OAAO,EAAEC,UAAU,CAAC,GAAG1B,QAAQ,CAAC,EAAE,CAAC;;EAE1C;EACA,MAAM,CAAC2B,gBAAgB,EAAEC,mBAAmB,CAAC,GAAG5B,QAAQ,CAAC,KAAK,CAAC;EAC/D,MAAM,CAAC6B,WAAW,EAAEC,cAAc,CAAC,GAAG9B,QAAQ,CAAC,IAAI,CAAC;EACpD,MAAM,CAAC+B,iBAAiB,EAAEC,oBAAoB,CAAC,GAAGhC,QAAQ,CAAC,KAAK,CAAC;;EAEjE;EACA,MAAM,CAACiC,eAAe,EAAEC,kBAAkB,CAAC,GAAGlC,QAAQ,CAAC;IACrDmC,UAAU,EAAE,EAAE;IACdC,QAAQ,EAAE;EACZ,CAAC,CAAC;;EAEF;EACA,MAAM,CAACC,KAAK,EAAEC,QAAQ,CAAC,GAAGtC,QAAQ,CAAC,EAAE,CAAC;EACtC,MAAM,CAACuC,cAAc,EAAEC,iBAAiB,CAAC,GAAGxC,QAAQ,CAAC,KAAK,CAAC;EAC3D,MAAM,CAACyC,SAAS,EAAEC,YAAY,CAAC,GAAG1C,QAAQ,CAAC,IAAI,CAAC;;EAEhD;EACA,MAAM2C,gBAAgB,GAAGtB,SAAS,CAACuB,IAAI,CAACC,CAAC,IAAIA,CAAC,CAACnC,EAAE,KAAKa,kBAAkB,CAAC,IAAIF,SAAS,CAAC,CAAC,CAAC;;EAEzF;EACA,MAAMyB,eAAe,GAAGrB,OAAO,CAACsB,MAAM,CAACF,CAAC,IAAIA,CAAC,CAACG,QAAQ,CAAC;;EAEvD;EACA,MAAMC,cAAc,GAAIvC,EAAE,IAAK;IAC7Bc,qBAAqB,CAACd,EAAE,CAAC;EAC3B,CAAC;;EAED;EACA,MAAMwC,qBAAqB,GAAIxC,EAAE,IAAK;IACpCgB,UAAU,CAACD,OAAO,CAAC0B,GAAG,CAACC,MAAM,IAC3BA,MAAM,CAAC1C,EAAE,KAAKA,EAAE,GAAG;MAAE,GAAG0C,MAAM;MAAEJ,QAAQ,EAAE,CAACI,MAAM,CAACJ;IAAS,CAAC,GAAGI,MACjE,CAAC,CAAC;EACJ,CAAC;;EAED;EACA,MAAMC,YAAY,GAAG,MAAAA,CAAOlB,UAAU,EAAEC,QAAQ,GAAG,EAAE,KAAK;IACxDJ,oBAAoB,CAAC,IAAI,CAAC;IAC1BF,cAAc,CAAC,IAAI,CAAC;IAEpB,IAAI;MACF;MACA,IAAI,CAACK,UAAU,CAACmB,UAAU,CAAC,IAAI,CAAC,IAAInB,UAAU,CAACoB,MAAM,KAAK,EAAE,EAAE;QAC5D,MAAM,IAAIC,KAAK,CAAC,4BAA4B,CAAC;MAC/C;;MAEA;MACA;;MAEA;MACA,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC;;MAEvD;MACA,MAAME,WAAW,GAAGzB,UAAU,CAAC0B,SAAS,CAAC1B,UAAU,CAACoB,MAAM,GAAG,CAAC,CAAC;MAC/D,MAAMO,WAAW,GAAG,KAAKF,WAAW,KAAKA,WAAW,CAACC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;;MAEtE;MACA,MAAME,SAAS,GAAG;QAChBrD,EAAE,EAAEe,OAAO,CAAC8B,MAAM,GAAG,CAAC;QACtBS,OAAO,EAAEF,WAAW;QACpB3B,UAAU,EAAEA,UAAU;QACtB8B,OAAO,EAAE,CAAC;QAAE;QACZjB,QAAQ,EAAE,IAAI;QACdZ,QAAQ,EAAEA,QAAQ,IAAI,UAAUX,OAAO,CAAC8B,MAAM,GAAG,CAAC;MACpD,CAAC;MAED7B,UAAU,CAAC,CAAC,GAAGD,OAAO,EAAEsC,SAAS,CAAC,CAAC;;MAEnC;MACA7B,kBAAkB,CAAC;QACjBC,UAAU,EAAE,EAAE;QACdC,QAAQ,EAAE;MACZ,CAAC,CAAC;;MAEF;MACA8B,kBAAkB,CAACH,SAAS,CAAC;MAE7B,OAAO;QAAEI,OAAO,EAAE,IAAI;QAAEC,OAAO,EAAE;MAA+B,CAAC;IACnE,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/CvC,cAAc,CAAC,4BAA4BuC,KAAK,CAACD,OAAO,EAAE,CAAC;MAC3D,OAAO;QAAED,OAAO,EAAE,KAAK;QAAEC,OAAO,EAAEC,KAAK,CAACD;MAAQ,CAAC;IACnD,CAAC,SAAS;MACRpC,oBAAoB,CAAC,KAAK,CAAC;IAC7B;EACF,CAAC;;EAED;EACA,MAAMuC,mBAAmB,GAAG,MAAAA,CAAA,KAAY;IACtC3C,mBAAmB,CAAC,IAAI,CAAC;IACzBE,cAAc,CAAC,IAAI,CAAC;IAEpB,IAAI;MACF;MACA;MACA,MAAM0C,cAAc,GAAG,MAAMf,OAAO,CAACgB,GAAG,CAAChD,OAAO,CAAC0B,GAAG,CAAC,MAAMC,MAAM,IAAI;QACnE,OAAOc,kBAAkB,CAACd,MAAM,CAAC;MACnC,CAAC,CAAC,CAAC;MAEH1B,UAAU,CAAC8C,cAAc,CAAC;IAC5B,CAAC,CAAC,OAAOH,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;MACvDvC,cAAc,CAAC,oCAAoCuC,KAAK,CAACD,OAAO,EAAE,CAAC;IACrE,CAAC,SAAS;MACRxC,mBAAmB,CAAC,KAAK,CAAC;IAC5B;EACF,CAAC;;EAED;EACA,MAAMsC,kBAAkB,GAAG,MAAOd,MAAM,IAAK;IAC3C,IAAI;MACF;MACA;;MAEA;MACA;MACA,MAAMsB,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGtE,YAAY,kCAAkC+C,MAAM,CAACY,OAAO,EAAE,CAAC;;MAE/F;MACA,IAAI,CAACU,QAAQ,CAACE,EAAE,EAAE;QAChB;QACA,MAAMC,aAAa,GAAGC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,GAAG;QAC9C,OAAO;UACL,GAAG3B,MAAM;UACTa,OAAO,EAAEY;QACX,CAAC;MACH;;MAEA;MACA,MAAMG,IAAI,GAAG,MAAMN,QAAQ,CAACO,IAAI,CAAC,CAAC;;MAElC;MACA,OAAO;QACL,GAAG7B,MAAM;QACTa,OAAO,EAAEe,IAAI,CAACf,OAAO,IAAIa,IAAI,CAACC,MAAM,CAAC,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC;MACpD,CAAC;IACH,CAAC,CAAC,OAAOV,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,qCAAqCjB,MAAM,CAACY,OAAO,GAAG,EAAEK,KAAK,CAAC;MAC5E;MACA,OAAOjB,MAAM;IACf;EACF,CAAC;;EAED;EACA,MAAM8B,UAAU,GAAG,MAAAA,CAAA,KAAY;IAC7B1C,iBAAiB,CAAC,IAAI,CAAC;IACvBE,YAAY,CAAC,IAAI,CAAC;IAClB,IAAI;MACF,MAAMgC,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGtE,YAAY,eAAe,CAAC;MAC5D,IAAI,CAACqE,QAAQ,CAACE,EAAE,EAAE;QAChB,MAAM,IAAIpB,KAAK,CAAC,uBAAuBkB,QAAQ,CAACS,MAAM,EAAE,CAAC;MAC3D;MACA,MAAMH,IAAI,GAAG,MAAMN,QAAQ,CAACO,IAAI,CAAC,CAAC;MAClC;MACA,MAAMG,SAAS,GAAGC,MAAM,CAACC,OAAO,CAACN,IAAI,CAAC3C,KAAK,IAAI,CAAC,CAAC,CAAC,CAACc,GAAG,CAAC,CAAC,CAACzC,EAAE,EAAE6E,IAAI,CAAC,MAAM;QACtE7E,EAAE;QACF,GAAG6E,IAAI;QACPC,SAAS,EAAE,IAAIC,IAAI,CAACF,IAAI,CAACG,UAAU;MACrC,CAAC,CAAC,CAAC;;MAEH;MACAN,SAAS,CAACO,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAACL,SAAS,GAAGI,CAAC,CAACJ,SAAS,CAAC;MACnDlD,QAAQ,CAAC8C,SAAS,CAAC;IACrB,CAAC,CAAC,OAAOf,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,wBAAwB,EAAEA,KAAK,CAAC;MAC9C3B,YAAY,CAAC,yBAAyB2B,KAAK,CAACD,OAAO,EAAE,CAAC;MACtD9B,QAAQ,CAAC,EAAE,CAAC;IACd,CAAC,SAAS;MACRE,iBAAiB,CAAC,KAAK,CAAC;IAC1B;EACF,CAAC;;EAED;EACA,MAAMsD,WAAW,GAAG,MAAAA,CAAA,KAAY;IAC9B,IAAI,CAACnD,gBAAgB,IAAIG,eAAe,CAACS,MAAM,KAAK,CAAC,EAAE;MACrD,OAAO;QAAEY,OAAO,EAAE,KAAK;QAAEC,OAAO,EAAE;MAA8C,CAAC;IACnF;IAEA,IAAI;MACF;MACA,IAAI2B,QAAQ,GAAG,EAAE;MACjB,IAAIC,WAAW,GAAG;QAChBC,YAAY,EAAEnD,eAAe,CAACK,GAAG,CAACN,CAAC,IAAIA,CAAC,CAACV,UAAU,CAAC;QACpD+D,0BAA0B,EAAE,EAAE;QAC9BC,4BAA4B,EAAE,EAAE;QAChCC,gBAAgB,EAAE,GAAGzD,gBAAgB,CAAChC,IAAI;MAC5C,CAAC;MAED,QAAQgC,gBAAgB,CAAC/B,IAAI;QAC3B,KAAK,OAAO;UACVmF,QAAQ,GAAG,2BAA2B;UACtCC,WAAW,GAAG;YACZ,GAAGA,WAAW;YACdK,aAAa,EAAE1D,gBAAgB,CAAC9B,YAAY,IAAI,OAAO;YACvDyF,UAAU,EAAE,IAAI;YAAE;YAClBC,MAAM,EAAE,CAAC;YACTvF,IAAI,EAAE,QAAQ;YACdwF,QAAQ,EAAE;UACZ,CAAC;UACD;QAEF,KAAK,QAAQ;UACXT,QAAQ,GAAG,sBAAsB;UACjCC,WAAW,GAAG;YACZ,GAAGA,WAAW;YACdS,aAAa,EAAE,SAAS;YACxBC,eAAe,EAAE,KAAK;YACtBH,MAAM,EAAE;UACV,CAAC;UACD;QAEF,KAAK,MAAM;UACTR,QAAQ,GAAG,oBAAoB;UAC/BC,WAAW,GAAG;YACZ,GAAGA,WAAW;YACdW,iBAAiB,EAAEhE,gBAAgB,CAAC7B,SAAS,IAAI,KAAK;YACtD8F,eAAe,EAAEjE,gBAAgB,CAAC5B,OAAO,IAAI,MAAM;YACnD8F,UAAU,EAAE,OAAO;YACnBN,MAAM,EAAE,CAAC;YACTvF,IAAI,EAAE;UACR,CAAC;UACD;QAEF,KAAK,MAAM;UACT+E,QAAQ,GAAG,oBAAoB;UAC/BC,WAAW,GAAG;YACZ,GAAGA,WAAW;YACdM,UAAU,EAAE,KAAK;YACjBE,QAAQ,EAAE,CAAC;YACXxF,IAAI,EAAE2B,gBAAgB,CAAC3B,IAAI,IAAI;UACjC,CAAC;UACD;QAEF;UACE,OAAO;YAAEmD,OAAO,EAAE,KAAK;YAAEC,OAAO,EAAE,8BAA8BzB,gBAAgB,CAAC/B,IAAI;UAAG,CAAC;MAC7F;;MAEA;MACA,MAAM8D,QAAQ,GAAG,MAAMC,KAAK,CAAC,GAAGtE,YAAY,GAAG0F,QAAQ,EAAE,EAAE;QACzDe,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE;QAClB,CAAC;QACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAClB,WAAW;MAClC,CAAC,CAAC;MAEF,IAAI,CAACtB,QAAQ,CAACE,EAAE,EAAE;QAChB,MAAM,IAAIpB,KAAK,CAAC,cAAckB,QAAQ,CAACS,MAAM,EAAE,CAAC;MAClD;MAEA,MAAMgC,MAAM,GAAG,MAAMzC,QAAQ,CAACO,IAAI,CAAC,CAAC;;MAEpC;MACA,MAAMC,UAAU,CAAC,CAAC;MAElB,OAAO;QAAEf,OAAO,EAAE,IAAI;QAAEC,OAAO,EAAE,+BAA+B;QAAEY,IAAI,EAAEmC;MAAO,CAAC;IAClF,CAAC,CAAC,OAAO9C,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,OAAO;QAAEF,OAAO,EAAE,KAAK;QAAEC,OAAO,EAAE,2BAA2BC,KAAK,CAACD,OAAO;MAAG,CAAC;IAChF;EACF,CAAC;;EAED;EACAlE,SAAS,CAAC,MAAM;IACdgF,UAAU,CAAC,CAAC;IACZX,mBAAmB,CAAC,CAAC;;IAErB;IACA,MAAM6C,aAAa,GAAGC,WAAW,CAACnC,UAAU,EAAE,KAAK,CAAC,CAAC,CAAC;IACtD,MAAMoC,eAAe,GAAGD,WAAW,CAAC9C,mBAAmB,EAAE,KAAK,CAAC,CAAC,CAAC;;IAEjE,OAAO,MAAM;MACXgD,aAAa,CAACH,aAAa,CAAC;MAC5BG,aAAa,CAACD,eAAe,CAAC;IAChC,CAAC,CAAC,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAME,wBAAwB,GAAGA,CAACC,KAAK,EAAEC,KAAK,KAAK;IACjDxF,kBAAkB,CAAC;MACjB,GAAGD,eAAe;MAClB,CAACwF,KAAK,GAAGC;IACX,CAAC,CAAC;EACJ,CAAC;;EAED;EACA,MAAMC,YAAY,GAAG;IACnBtG,SAAS;IACTsB,gBAAgB;IAChBpB,kBAAkB;IAClB0B,cAAc;IACdxB,OAAO;IACPyB,qBAAqB;IACrBJ,eAAe;IACfT,KAAK;IACLE,cAAc;IACdE,SAAS;IACTyC,UAAU;IACVY,WAAW;IACX;IACAnE,gBAAgB;IAChBE,WAAW;IACX0C,mBAAmB;IACnBlB,YAAY;IACZtB,iBAAiB;IACjBE,eAAe;IACfuF;EACF,CAAC;EAED,oBACEpH,OAAA,CAACa,UAAU,CAAC2G,QAAQ;IAACF,KAAK,EAAEC,YAAa;IAAAxG,QAAA,EACtCA;EAAQ;IAAA0G,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACU,CAAC;AAE1B,CAAC;;AAED;AAAA5G,EAAA,CAnUaF,WAAW;AAAA+G,EAAA,GAAX/G,WAAW;AAoUxB,OAAO,MAAMgH,aAAa,GAAGA,CAAA,KAAM;EAAAC,GAAA;EACjC,MAAMC,OAAO,GAAGnI,UAAU,CAACgB,UAAU,CAAC;EACtC,IAAImH,OAAO,KAAKC,SAAS,EAAE;IACzB,MAAM,IAAI7E,KAAK,CAAC,kDAAkD,CAAC;EACrE;EACA,OAAO4E,OAAO;AAChB,CAAC;AAACD,GAAA,CANWD,aAAa;AAQ1B,eAAejH,UAAU;AAAC,IAAAgH,EAAA;AAAAK,YAAA,CAAAL,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}