{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\cymst\\\\Documents\\\\monad bot\\\\frontend\\\\src\\\\context\\\\AppContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useState, useContext, useEffect } from 'react';\n\n// Define API base URL - same as in the original LogsPage.js\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';\n\n// Mock data for workflows (to be replaced by API data eventually)\nconst MOCK_WORKFLOWS = [{\n  id: 1,\n  name: 'Workflow Name is Test Ja',\n  type: 'stake',\n  contractType: 'kitsu'\n}, {\n  id: 2,\n  name: 'NFT Minter workflow',\n  type: 'deploy',\n  contractType: 'counter'\n}, {\n  id: 3,\n  name: 'Workflow#5',\n  type: 'swap',\n  fromToken: 'ETH',\n  toToken: 'USDC'\n}, {\n  id: 4,\n  name: 'Token Send Workflow',\n  type: 'send',\n  mode: 'random'\n}];\n\n// Create the context\nconst AppContext = /*#__PURE__*/createContext();\n\n// Provider component that wraps the app\nexport const AppProvider = ({\n  children\n}) => {\n  _s();\n  // Workflows state\n  const [workflows, setWorkflows] = useState(MOCK_WORKFLOWS);\n  const [selectedWorkflowId, setSelectedWorkflowId] = useState(2); // Default to NFT Minter\n\n  // Wallets state - starts empty now\n  const [wallets, setWallets] = useState([]);\n\n  // Wallet loading state\n  const [isLoadingWallets, setIsLoadingWallets] = useState(false);\n  const [walletError, setWalletError] = useState(null);\n  const [isImportingWallet, setIsImportingWallet] = useState(false);\n\n  // New wallet import form state\n  const [newWalletImport, setNewWalletImport] = useState({\n    privateKey: '',\n    nickname: ''\n  });\n\n  // Tasks/runs state - will be fetched from API\n  const [tasks, setTasks] = useState([]);\n  const [isLoadingTasks, setIsLoadingTasks] = useState(false);\n  const [taskError, setTaskError] = useState(null);\n\n  // Get the selected workflow\n  const selectedWorkflow = workflows.find(w => w.id === selectedWorkflowId) || workflows[0];\n\n  // Get selected wallets (for running workflows)\n  const selectedWallets = wallets.filter(w => w.selected);\n\n  // Function to select a workflow\n  const selectWorkflow = id => {\n    setSelectedWorkflowId(id);\n  };\n\n  // Function to toggle wallet selection\n  const toggleWalletSelection = id => {\n    setWallets(wallets.map(wallet => wallet.id === id ? {\n      ...wallet,\n      selected: !wallet.selected\n    } : wallet));\n  };\n\n  // Function to import a new wallet using backend API\n  const importWallet = async (privateKey, nickname = '') => {\n    setIsImportingWallet(true);\n    setWalletError(null);\n    try {\n      // Basic frontend validation (backend validates format too)\n      if (!privateKey.startsWith('0x') || privateKey.length !== 66) {\n        throw new Error('Invalid private key format (must be 0x followed by 64 hex chars)');\n      }\n\n      // Step 1: Call backend to get the real address from the private key\n      const addressResponse = await fetch(`${API_BASE_URL}/api/v1/get-address-from-key`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          private_key: privateKey\n        })\n      });\n      if (!addressResponse.ok) {\n        let errorMsg = 'Failed to derive address from key.';\n        try {\n          const errorData = await addressResponse.json();\n          errorMsg = errorData.detail || errorMsg;\n        } catch {/* Ignore if response body is not JSON */}\n        throw new Error(errorMsg);\n      }\n      const addressData = await addressResponse.json();\n      const realAddress = addressData.address;\n\n      // Check if wallet with this address already exists\n      if (wallets.some(w => w.address === realAddress)) {\n        throw new Error(`Wallet with address ${realAddress} already exists.`);\n      }\n\n      // Create the new wallet object (balance will be fetched separately)\n      const newWallet = {\n        id: wallets.length > 0 ? Math.max(...wallets.map(w => w.id)) + 1 : 1,\n        // Ensure unique ID\n        address: realAddress,\n        privateKey: privateKey,\n        // Still need to store this for running workflows\n        balance: null,\n        // Initialize balance as null, will be fetched\n        selected: true,\n        nickname: nickname || `Wallet ${realAddress.substring(0, 6)}...` // Default nickname\n      };\n\n      // Add wallet temporarily with null balance\n      setWallets(prevWallets => [...prevWallets, newWallet]);\n\n      // Clear form\n      setNewWalletImport({\n        privateKey: '',\n        nickname: ''\n      });\n\n      // Step 2: Fetch the balance for the new wallet\n      await fetchWalletBalance(newWallet.id, newWallet.address); // Pass ID and Address\n\n      return {\n        success: true,\n        message: 'Wallet imported successfully'\n      };\n    } catch (error) {\n      console.error('Error importing wallet:', error);\n      setWalletError(`Failed to import wallet: ${error.message}`);\n      // Optional: Remove the temporarily added wallet if fetch fails?\n      // setWallets(prevWallets => prevWallets.filter(w => w.address !== realAddress));\n      return {\n        success: false,\n        message: error.message\n      };\n    } finally {\n      setIsImportingWallet(false);\n    }\n  };\n\n  // Function to fetch all wallet balances\n  const fetchWalletBalances = async () => {\n    setIsLoadingWallets(true);\n    setWalletError(null);\n\n    // Create promises for each wallet balance fetch\n    const balancePromises = wallets.map(wallet => fetchWalletBalance(wallet.id, wallet.address) // Pass ID and address\n    );\n    try {\n      await Promise.all(balancePromises);\n      // Balances are updated directly in fetchWalletBalance via setWallets\n    } catch (error) {\n      // Errors are handled within fetchWalletBalance, maybe set a general error here?\n      console.error('Error fetching some wallet balances:', error);\n      // setWalletError(`Failed to fetch some balances: ${error.message}`); // Optional: More specific error\n    } finally {\n      setIsLoadingWallets(false);\n    }\n  };\n\n  // Function to fetch a single wallet's balance using backend API\n  const fetchWalletBalance = async (walletId, walletAddress) => {\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/v1/get-balance/${walletAddress}`);\n      if (!response.ok) {\n        let errorMsg = `Failed to fetch balance for ${walletAddress}. Status: ${response.status}`;\n        try {\n          const errorData = await response.json();\n          errorMsg = `${errorMsg} - ${errorData.detail || 'Unknown error'}`;\n        } catch {/* Ignore */}\n        throw new Error(errorMsg);\n      }\n      const data = await response.json();\n      const balance = data.balance; // Backend now returns balance as string\n\n      // Update the specific wallet in the state\n      setWallets(prevWallets => prevWallets.map(wallet => wallet.id === walletId ? {\n        ...wallet,\n        balance: balance\n      } : wallet));\n      // Return value isn't strictly needed here as state is updated directly\n      // return { ...wallet, balance: balance }; \n    } catch (error) {\n      console.error(`Error fetching balance for wallet ${walletAddress} (ID: ${walletId}):`, error);\n      // Update the specific wallet with an error indicator or keep null balance\n      setWallets(prevWallets => prevWallets.map(wallet => wallet.id === walletId ? {\n        ...wallet,\n        balance: 'Error'\n      } // Indicate error fetching balance\n      : wallet));\n      // Propagate the error for potential handling in fetchWalletBalances\n      throw error; // Allow Promise.all in fetchWalletBalances to catch it\n    }\n  };\n\n  // Function to fetch tasks from API\n  const fetchTasks = async () => {\n    setIsLoadingTasks(true);\n    setTaskError(null);\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/v1/tasks`);\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      // Process and format the tasks data\n      const tasksData = Object.entries(data.tasks || {}).map(([id, task]) => ({\n        id,\n        ...task,\n        startTime: new Date(task.start_time)\n      }));\n\n      // Sort by start time, newest first\n      tasksData.sort((a, b) => b.startTime - a.startTime);\n      setTasks(tasksData);\n    } catch (error) {\n      console.error(\"Failed to fetch tasks:\", error);\n      setTaskError(`Error fetching tasks: ${error.message}`);\n      setTasks([]);\n    } finally {\n      setIsLoadingTasks(false);\n    }\n  };\n\n  // Function to run a workflow via the API\n  const runWorkflow = async () => {\n    if (!selectedWorkflow || selectedWallets.length === 0) {\n      return {\n        success: false,\n        message: \"No workflow selected or no wallets selected\"\n      };\n    }\n    try {\n      // Depending on the workflow type, call different API endpoints\n      let endpoint = '';\n      let payloadData = {\n        private_keys: selectedWallets.map(w => w.privateKey),\n        delay_between_keys_seconds: 30,\n        delay_between_cycles_seconds: 60,\n        task_description: `${selectedWorkflow.name} (Manual run)`\n      };\n      switch (selectedWorkflow.type) {\n        case 'stake':\n          endpoint = '/api/v1/start-stake-cycle';\n          payloadData = {\n            ...payloadData,\n            contract_type: selectedWorkflow.contractType || 'kitsu',\n            amount_mon: 0.01,\n            // Default small amount\n            cycles: 1,\n            mode: 'random',\n            tx_count: 1\n          };\n          break;\n        case 'deploy':\n          endpoint = '/api/v1/start-deploy';\n          payloadData = {\n            ...payloadData,\n            contract_name: 'Counter',\n            contract_symbol: 'CNT',\n            cycles: 1\n          };\n          break;\n        case 'swap':\n          endpoint = '/api/v1/start-swap';\n          payloadData = {\n            ...payloadData,\n            token_from_symbol: selectedWorkflow.fromToken || 'ETH',\n            token_to_symbol: selectedWorkflow.toToken || 'USDC',\n            amount_str: '0.001',\n            cycles: 1,\n            mode: 'manual'\n          };\n          break;\n        case 'send':\n          endpoint = '/api/v1/start-send';\n          payloadData = {\n            ...payloadData,\n            amount_mon: 0.001,\n            tx_count: 1,\n            mode: selectedWorkflow.mode || 'random'\n          };\n          break;\n        default:\n          return {\n            success: false,\n            message: `Unsupported workflow type: ${selectedWorkflow.type}`\n          };\n      }\n\n      // Make the API call to run the workflow\n      const response = await fetch(`${API_BASE_URL}${endpoint}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payloadData)\n      });\n      if (!response.ok) {\n        throw new Error(`API error: ${response.status}`);\n      }\n      const result = await response.json();\n\n      // Refresh the tasks list after starting a new one\n      await fetchTasks();\n      return {\n        success: true,\n        message: \"Workflow started successfully\",\n        data: result\n      };\n    } catch (error) {\n      console.error(\"Error running workflow:\", error);\n      return {\n        success: false,\n        message: `Failed to run workflow: ${error.message}`\n      };\n    }\n  };\n\n  // Fetch tasks and wallet balances when component mounts\n  useEffect(() => {\n    fetchTasks();\n    // Fetch balances only if wallets exist, or maybe fetch empty\n    if (wallets.length > 0) {\n      fetchWalletBalances();\n    }\n\n    // Set up polling intervals\n    const tasksInterval = setInterval(fetchTasks, 10000); // Refresh tasks every 10 seconds\n    const walletsInterval = setInterval(fetchWalletBalances, 30000); // Refresh wallets every 30 seconds\n\n    return () => {\n      clearInterval(tasksInterval);\n      clearInterval(walletsInterval);\n    }; // Clean up on unmount\n  }, []); // Rerun if fetchWalletBalances identity changes? No, it's stable.\n\n  // Update newWalletImport state\n  const handleWalletImportChange = (field, value) => {\n    setNewWalletImport({\n      ...newWalletImport,\n      [field]: value\n    });\n  };\n\n  // The context value that will be passed to consumers\n  const contextValue = {\n    workflows,\n    selectedWorkflow,\n    selectedWorkflowId,\n    selectWorkflow,\n    wallets,\n    toggleWalletSelection,\n    selectedWallets,\n    tasks,\n    isLoadingTasks,\n    taskError,\n    fetchTasks,\n    runWorkflow,\n    // New wallet functions\n    isLoadingWallets,\n    walletError,\n    fetchWalletBalances,\n    importWallet,\n    isImportingWallet,\n    newWalletImport,\n    handleWalletImportChange\n  };\n  return /*#__PURE__*/_jsxDEV(AppContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 364,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use the app context\n_s(AppProvider, \"Jr0Hhyx6+Ypk67ETpqcQPdB7xto=\");\n_c = AppProvider;\nexport const useAppContext = () => {\n  _s2();\n  const context = useContext(AppContext);\n  if (context === undefined) {\n    throw new Error('useAppContext must be used within an AppProvider');\n  }\n  return context;\n};\n_s2(useAppContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default AppContext;\nvar _c;\n$RefreshReg$(_c, \"AppProvider\");","map":{"version":3,"names":["React","createContext","useState","useContext","useEffect","jsxDEV","_jsxDEV","API_BASE_URL","process","env","REACT_APP_API_BASE_URL","MOCK_WORKFLOWS","id","name","type","contractType","fromToken","toToken","mode","AppContext","AppProvider","children","_s","workflows","setWorkflows","selectedWorkflowId","setSelectedWorkflowId","wallets","setWallets","isLoadingWallets","setIsLoadingWallets","walletError","setWalletError","isImportingWallet","setIsImportingWallet","newWalletImport","setNewWalletImport","privateKey","nickname","tasks","setTasks","isLoadingTasks","setIsLoadingTasks","taskError","setTaskError","selectedWorkflow","find","w","selectedWallets","filter","selected","selectWorkflow","toggleWalletSelection","map","wallet","importWallet","startsWith","length","Error","addressResponse","fetch","method","headers","body","JSON","stringify","private_key","ok","errorMsg","errorData","json","detail","addressData","realAddress","address","some","newWallet","Math","max","balance","substring","prevWallets","fetchWalletBalance","success","message","error","console","fetchWalletBalances","balancePromises","Promise","all","walletId","walletAddress","response","status","data","fetchTasks","tasksData","Object","entries","task","startTime","Date","start_time","sort","a","b","runWorkflow","endpoint","payloadData","private_keys","delay_between_keys_seconds","delay_between_cycles_seconds","task_description","contract_type","amount_mon","cycles","tx_count","contract_name","contract_symbol","token_from_symbol","token_to_symbol","amount_str","result","tasksInterval","setInterval","walletsInterval","clearInterval","handleWalletImportChange","field","value","contextValue","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAppContext","_s2","context","undefined","$RefreshReg$"],"sources":["C:/Users/cymst/Documents/monad bot/frontend/src/context/AppContext.js"],"sourcesContent":["import React, { createContext, useState, useContext, useEffect } from 'react';\r\n\r\n// Define API base URL - same as in the original LogsPage.js\r\nconst API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000';\r\n\r\n// Mock data for workflows (to be replaced by API data eventually)\r\nconst MOCK_WORKFLOWS = [\r\n  { id: 1, name: 'Workflow Name is Test Ja', type: 'stake', contractType: 'kitsu' },\r\n  { id: 2, name: 'NFT Minter workflow', type: 'deploy', contractType: 'counter' },\r\n  { id: 3, name: 'Workflow#5', type: 'swap', fromToken: 'ETH', toToken: 'USDC' },\r\n  { id: 4, name: 'Token Send Workflow', type: 'send', mode: 'random' },\r\n];\r\n\r\n// Create the context\r\nconst AppContext = createContext();\r\n\r\n// Provider component that wraps the app\r\nexport const AppProvider = ({ children }) => {\r\n  // Workflows state\r\n  const [workflows, setWorkflows] = useState(MOCK_WORKFLOWS);\r\n  const [selectedWorkflowId, setSelectedWorkflowId] = useState(2); // Default to NFT Minter\r\n  \r\n  // Wallets state - starts empty now\r\n  const [wallets, setWallets] = useState([]);\r\n  \r\n  // Wallet loading state\r\n  const [isLoadingWallets, setIsLoadingWallets] = useState(false);\r\n  const [walletError, setWalletError] = useState(null);\r\n  const [isImportingWallet, setIsImportingWallet] = useState(false);\r\n  \r\n  // New wallet import form state\r\n  const [newWalletImport, setNewWalletImport] = useState({\r\n    privateKey: '',\r\n    nickname: ''\r\n  });\r\n\r\n  // Tasks/runs state - will be fetched from API\r\n  const [tasks, setTasks] = useState([]);\r\n  const [isLoadingTasks, setIsLoadingTasks] = useState(false);\r\n  const [taskError, setTaskError] = useState(null);\r\n  \r\n  // Get the selected workflow\r\n  const selectedWorkflow = workflows.find(w => w.id === selectedWorkflowId) || workflows[0];\r\n  \r\n  // Get selected wallets (for running workflows)\r\n  const selectedWallets = wallets.filter(w => w.selected);\r\n  \r\n  // Function to select a workflow\r\n  const selectWorkflow = (id) => {\r\n    setSelectedWorkflowId(id);\r\n  };\r\n  \r\n  // Function to toggle wallet selection\r\n  const toggleWalletSelection = (id) => {\r\n    setWallets(wallets.map(wallet => \r\n      wallet.id === id ? { ...wallet, selected: !wallet.selected } : wallet\r\n    ));\r\n  };\r\n  \r\n  // Function to import a new wallet using backend API\r\n  const importWallet = async (privateKey, nickname = '') => {\r\n    setIsImportingWallet(true);\r\n    setWalletError(null);\r\n    \r\n    try {\r\n      // Basic frontend validation (backend validates format too)\r\n      if (!privateKey.startsWith('0x') || privateKey.length !== 66) {\r\n        throw new Error('Invalid private key format (must be 0x followed by 64 hex chars)');\r\n      }\r\n      \r\n      // Step 1: Call backend to get the real address from the private key\r\n      const addressResponse = await fetch(`${API_BASE_URL}/api/v1/get-address-from-key`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({ private_key: privateKey }),\r\n      });\r\n\r\n      if (!addressResponse.ok) {\r\n        let errorMsg = 'Failed to derive address from key.';\r\n        try {\r\n            const errorData = await addressResponse.json();\r\n            errorMsg = errorData.detail || errorMsg;\r\n        } catch { /* Ignore if response body is not JSON */ }\r\n        throw new Error(errorMsg);\r\n      }\r\n\r\n      const addressData = await addressResponse.json();\r\n      const realAddress = addressData.address;\r\n\r\n      // Check if wallet with this address already exists\r\n      if (wallets.some(w => w.address === realAddress)) {\r\n        throw new Error(`Wallet with address ${realAddress} already exists.`);\r\n      }\r\n\r\n      // Create the new wallet object (balance will be fetched separately)\r\n      const newWallet = {\r\n        id: wallets.length > 0 ? Math.max(...wallets.map(w => w.id)) + 1 : 1, // Ensure unique ID\r\n        address: realAddress,\r\n        privateKey: privateKey, // Still need to store this for running workflows\r\n        balance: null, // Initialize balance as null, will be fetched\r\n        selected: true,\r\n        nickname: nickname || `Wallet ${realAddress.substring(0, 6)}...` // Default nickname\r\n      };\r\n      \r\n      // Add wallet temporarily with null balance\r\n      setWallets(prevWallets => [...prevWallets, newWallet]);\r\n      \r\n      // Clear form\r\n      setNewWalletImport({ privateKey: '', nickname: '' });\r\n      \r\n      // Step 2: Fetch the balance for the new wallet\r\n      await fetchWalletBalance(newWallet.id, newWallet.address); // Pass ID and Address\r\n      \r\n      return { success: true, message: 'Wallet imported successfully' };\r\n\r\n    } catch (error) {\r\n      console.error('Error importing wallet:', error);\r\n      setWalletError(`Failed to import wallet: ${error.message}`);\r\n      // Optional: Remove the temporarily added wallet if fetch fails?\r\n      // setWallets(prevWallets => prevWallets.filter(w => w.address !== realAddress));\r\n      return { success: false, message: error.message };\r\n    } finally {\r\n      setIsImportingWallet(false);\r\n    }\r\n  };\r\n  \r\n  // Function to fetch all wallet balances\r\n  const fetchWalletBalances = async () => {\r\n    setIsLoadingWallets(true);\r\n    setWalletError(null);\r\n    \r\n    // Create promises for each wallet balance fetch\r\n    const balancePromises = wallets.map(wallet => \r\n        fetchWalletBalance(wallet.id, wallet.address) // Pass ID and address\r\n    );\r\n\r\n    try {\r\n        await Promise.all(balancePromises);\r\n        // Balances are updated directly in fetchWalletBalance via setWallets\r\n    } catch (error) {\r\n        // Errors are handled within fetchWalletBalance, maybe set a general error here?\r\n        console.error('Error fetching some wallet balances:', error); \r\n        // setWalletError(`Failed to fetch some balances: ${error.message}`); // Optional: More specific error\r\n    } finally {\r\n        setIsLoadingWallets(false);\r\n    }\r\n  };\r\n  \r\n  // Function to fetch a single wallet's balance using backend API\r\n  const fetchWalletBalance = async (walletId, walletAddress) => {\r\n    try {\r\n        const response = await fetch(`${API_BASE_URL}/api/v1/get-balance/${walletAddress}`);\r\n        \r\n        if (!response.ok) {\r\n            let errorMsg = `Failed to fetch balance for ${walletAddress}. Status: ${response.status}`;\r\n            try {\r\n                const errorData = await response.json();\r\n                errorMsg = `${errorMsg} - ${errorData.detail || 'Unknown error'}`;\r\n            } catch { /* Ignore */ }\r\n            throw new Error(errorMsg);\r\n        }\r\n        \r\n        const data = await response.json();\r\n        const balance = data.balance; // Backend now returns balance as string\r\n\r\n        // Update the specific wallet in the state\r\n        setWallets(prevWallets => \r\n            prevWallets.map(wallet => \r\n                wallet.id === walletId \r\n                    ? { ...wallet, balance: balance } \r\n                    : wallet\r\n            )\r\n        );\r\n        // Return value isn't strictly needed here as state is updated directly\r\n        // return { ...wallet, balance: balance }; \r\n\r\n    } catch (error) {\r\n        console.error(`Error fetching balance for wallet ${walletAddress} (ID: ${walletId}):`, error);\r\n        // Update the specific wallet with an error indicator or keep null balance\r\n        setWallets(prevWallets => \r\n            prevWallets.map(wallet => \r\n                wallet.id === walletId \r\n                    ? { ...wallet, balance: 'Error' } // Indicate error fetching balance\r\n                    : wallet\r\n            )\r\n        );\r\n        // Propagate the error for potential handling in fetchWalletBalances\r\n        throw error; // Allow Promise.all in fetchWalletBalances to catch it\r\n    }\r\n  };\r\n  \r\n  // Function to fetch tasks from API\r\n  const fetchTasks = async () => {\r\n    setIsLoadingTasks(true);\r\n    setTaskError(null);\r\n    try {\r\n      const response = await fetch(`${API_BASE_URL}/api/v1/tasks`);\r\n      if (!response.ok) {\r\n        throw new Error(`HTTP error! status: ${response.status}`);\r\n      }\r\n      const data = await response.json();\r\n      // Process and format the tasks data\r\n      const tasksData = Object.entries(data.tasks || {}).map(([id, task]) => ({\r\n        id,\r\n        ...task,\r\n        startTime: new Date(task.start_time),\r\n      }));\r\n      \r\n      // Sort by start time, newest first\r\n      tasksData.sort((a, b) => b.startTime - a.startTime);\r\n      setTasks(tasksData);\r\n    } catch (error) {\r\n      console.error(\"Failed to fetch tasks:\", error);\r\n      setTaskError(`Error fetching tasks: ${error.message}`);\r\n      setTasks([]);\r\n    } finally {\r\n      setIsLoadingTasks(false);\r\n    }\r\n  };\r\n  \r\n  // Function to run a workflow via the API\r\n  const runWorkflow = async () => {\r\n    if (!selectedWorkflow || selectedWallets.length === 0) {\r\n      return { success: false, message: \"No workflow selected or no wallets selected\" };\r\n    }\r\n    \r\n    try {\r\n      // Depending on the workflow type, call different API endpoints\r\n      let endpoint = '';\r\n      let payloadData = {\r\n        private_keys: selectedWallets.map(w => w.privateKey),\r\n        delay_between_keys_seconds: 30,\r\n        delay_between_cycles_seconds: 60,\r\n        task_description: `${selectedWorkflow.name} (Manual run)`\r\n      };\r\n      \r\n      switch (selectedWorkflow.type) {\r\n        case 'stake':\r\n          endpoint = '/api/v1/start-stake-cycle';\r\n          payloadData = {\r\n            ...payloadData,\r\n            contract_type: selectedWorkflow.contractType || 'kitsu',\r\n            amount_mon: 0.01, // Default small amount\r\n            cycles: 1,\r\n            mode: 'random',\r\n            tx_count: 1,\r\n          };\r\n          break;\r\n        \r\n        case 'deploy':\r\n          endpoint = '/api/v1/start-deploy';\r\n          payloadData = {\r\n            ...payloadData,\r\n            contract_name: 'Counter',\r\n            contract_symbol: 'CNT',\r\n            cycles: 1,\r\n          };\r\n          break;\r\n          \r\n        case 'swap':\r\n          endpoint = '/api/v1/start-swap';\r\n          payloadData = {\r\n            ...payloadData,\r\n            token_from_symbol: selectedWorkflow.fromToken || 'ETH',\r\n            token_to_symbol: selectedWorkflow.toToken || 'USDC',\r\n            amount_str: '0.001',\r\n            cycles: 1,\r\n            mode: 'manual',\r\n          };\r\n          break;\r\n          \r\n        case 'send':\r\n          endpoint = '/api/v1/start-send';\r\n          payloadData = {\r\n            ...payloadData,\r\n            amount_mon: 0.001,\r\n            tx_count: 1,\r\n            mode: selectedWorkflow.mode || 'random',\r\n          };\r\n          break;\r\n          \r\n        default:\r\n          return { success: false, message: `Unsupported workflow type: ${selectedWorkflow.type}` };\r\n      }\r\n      \r\n      // Make the API call to run the workflow\r\n      const response = await fetch(`${API_BASE_URL}${endpoint}`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(payloadData),\r\n      });\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`API error: ${response.status}`);\r\n      }\r\n      \r\n      const result = await response.json();\r\n      \r\n      // Refresh the tasks list after starting a new one\r\n      await fetchTasks();\r\n      \r\n      return { success: true, message: \"Workflow started successfully\", data: result };\r\n    } catch (error) {\r\n      console.error(\"Error running workflow:\", error);\r\n      return { success: false, message: `Failed to run workflow: ${error.message}` };\r\n    }\r\n  };\r\n  \r\n  // Fetch tasks and wallet balances when component mounts\r\n  useEffect(() => {\r\n    fetchTasks();\r\n    // Fetch balances only if wallets exist, or maybe fetch empty\r\n    if (wallets.length > 0) {\r\n        fetchWalletBalances();\r\n    }\r\n    \r\n    // Set up polling intervals\r\n    const tasksInterval = setInterval(fetchTasks, 10000); // Refresh tasks every 10 seconds\r\n    const walletsInterval = setInterval(fetchWalletBalances, 30000); // Refresh wallets every 30 seconds\r\n    \r\n    return () => {\r\n      clearInterval(tasksInterval);\r\n      clearInterval(walletsInterval);\r\n    }; // Clean up on unmount\r\n  }, []); // Rerun if fetchWalletBalances identity changes? No, it's stable.\r\n  \r\n  // Update newWalletImport state\r\n  const handleWalletImportChange = (field, value) => {\r\n    setNewWalletImport({\r\n      ...newWalletImport,\r\n      [field]: value\r\n    });\r\n  };\r\n  \r\n  // The context value that will be passed to consumers\r\n  const contextValue = {\r\n    workflows,\r\n    selectedWorkflow,\r\n    selectedWorkflowId,\r\n    selectWorkflow,\r\n    wallets,\r\n    toggleWalletSelection,\r\n    selectedWallets,\r\n    tasks,\r\n    isLoadingTasks,\r\n    taskError,\r\n    fetchTasks,\r\n    runWorkflow,\r\n    // New wallet functions\r\n    isLoadingWallets,\r\n    walletError,\r\n    fetchWalletBalances,\r\n    importWallet,\r\n    isImportingWallet,\r\n    newWalletImport,\r\n    handleWalletImportChange\r\n  };\r\n  \r\n  return (\r\n    <AppContext.Provider value={contextValue}>\r\n      {children}\r\n    </AppContext.Provider>\r\n  );\r\n};\r\n\r\n// Custom hook to use the app context\r\nexport const useAppContext = () => {\r\n  const context = useContext(AppContext);\r\n  if (context === undefined) {\r\n    throw new Error('useAppContext must be used within an AppProvider');\r\n  }\r\n  return context;\r\n};\r\n\r\nexport default AppContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}